/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2021. All rights reserved.
 */

#include "BuildDatabase.h"

#include "BaseCommand.h"
#include "FeaturesFilter.h"
#include "Paths.h"
#include "building/CompileCommand.h"
#include "exceptions/CompilationDatabaseException.h"
#include "utils/DynamicLibraryUtils.h"
#include "utils/JsonUtils.h"
#include "utils/StringUtils.h"

#include "loguru.h"

#include <functional>
#include <queue>
#include <set>
#include <unordered_map>

using std::set;
using std::string;

static std::string tryConvertOptionToPath(const std::string &possibleFilePath,
                                          const fs::path &dirPath) {
    if (StringUtils::startsWith(possibleFilePath, "-")) {
        return possibleFilePath;
    }
    fs::path fullFilePath;
    try {
        fullFilePath = Paths::getCCJsonFileFullPath(possibleFilePath, dirPath);
    } catch (...) {
        return possibleFilePath;
    }
    return fs::exists(fullFilePath) ? fullFilePath.string() : possibleFilePath;
}

BuildDatabase::BuildDatabase(const fs::path& buildCommandsJsonPath,
                             fs::path serverBuildDir,
                             utbot::ProjectContext projectContext)
    : serverBuildDir(std::move(serverBuildDir)), projectContext(std::move(projectContext)) {
    linkCommandsJsonPath = fs::canonical(buildCommandsJsonPath / "link_commands.json");
    compileCommandsJsonPath = fs::canonical(buildCommandsJsonPath / "compile_commands.json");
    if (!fs::exists(linkCommandsJsonPath) || !fs::exists(compileCommandsJsonPath)) {
        throw CompilationDatabaseException("Couldn't open link_commands.json or compile_commands.json files");
    }
    auto linkCommandsJson = JsonUtils::getJsonFromFile(linkCommandsJsonPath);
    auto compileCommandsJson = JsonUtils::getJsonFromFile(compileCommandsJsonPath);

    createClangCompileCommandsJson(buildCommandsJsonPath, compileCommandsJson);
    initInfo(linkCommandsJson);
    addLocalSharedLibraries();
    fillTargetInfoParents();
}

std::shared_ptr<BuildDatabase> BuildDatabase::create(const utbot::ProjectContext &projectContext) {
    fs::path compileCommandsJsonPath =
        CompilationUtils::substituteRemotePathToCompileCommandsJsonPath(
            projectContext.projectPath, projectContext.buildDirRelativePath);
    fs::path serverBuildDir = Paths::getTmpDir(projectContext.projectName);
    std::shared_ptr<BuildDatabase> buildDatabase =
        std::make_shared<BuildDatabase>(compileCommandsJsonPath, serverBuildDir, projectContext);
    return buildDatabase;
}

fs::path BuildDatabase::createExplicitObjectFileCompilationCommand(const std::shared_ptr<ObjectFileInfo> &objectInfo) {
    if (Paths::isSourceFile(objectInfo->getSourcePath())) {
        auto outputFile = objectInfo->getOutputFile();
        auto tmpObjectFileName =
            Paths::createTemporaryObjectFile(outputFile, objectInfo->getSourcePath());
        objectInfo->setOutputFile(tmpObjectFileName);
        // redirect existing compilation command to temporary file
        LOG_IF_S(ERROR, CollectionUtils::containsKey(objectFileInfos, tmpObjectFileName))
            << "Temporary object file name generated by UTBot is already present in the "
               "project: "
            << tmpObjectFileName;
        objectInfo->linkUnit = outputFile;
        objectFileInfos[tmpObjectFileName] = objectInfo;
        return tmpObjectFileName;
    } else {
        return objectInfo->getSourcePath();
    }
}

void BuildDatabase::createClangCompileCommandsJson(const fs::path &buildCommandsJsonPath,
                                                   const nlohmann::json &compileCommandsJson) {
    CollectionUtils::MapFileTo<std::pair<nlohmann::json, std::shared_ptr<ObjectFileInfo>>> fileCompileCommands;
    for (auto const& compileCommand: compileCommandsJson) {
        auto objectInfo = std::make_shared<ObjectFileInfo>();

        fs::path directory = compileCommand.at("directory").get<string>();
        fs::path jsonFile = compileCommand.at("file").get<std::string>();
        fs::path sourceFile = Paths::getCCJsonFileFullPath(jsonFile, directory);

        std::vector<string> jsonArguments;
        if (compileCommand.contains("command")) {
            string command = compileCommand.at("command");
            jsonArguments = StringUtils::splitByWhitespaces(command);
        } else {
            jsonArguments = std::vector<string>(compileCommand.at("arguments"));
        }
        std::transform(jsonArguments.begin(), jsonArguments.end(), jsonArguments.begin(),
                       [&directory](const string &argument) {
                           return tryConvertOptionToPath(argument, directory);
                       });
        objectInfo->command = utbot::CompileCommand(jsonArguments, directory, sourceFile);
        fs::path outputFile = objectInfo->getOutputFile();
        fs::path kleeFilePathTemplate =
            Paths::createNewDirForFile(sourceFile, projectContext.buildDir, serverBuildDir);
        fs::path kleeFile = Paths::addSuffix(kleeFilePathTemplate, "_klee");
        objectInfo->kleeFilesInfo = std::make_shared<KleeFilesInfo>(kleeFile);

        if (CollectionUtils::containsKey(objectFileInfos, outputFile) || CollectionUtils::containsKey(targetInfos, outputFile)) {
            /*
             * If the condition above is true, that means that the output file
             * is built from multiple sources. Hence, it is not an object file,
             * but an executable, and it should be treated as a target.
             * This is a hack. This inconsistency is produced by Bear
             * when it treats a Makefile command like
             * gcc -o output a.c b.c c.c
             * This code is creating artificial compile and link commands, similar
             * to commands Bear generates from CMake command like
             * add_executable(output a.c b.c c.c)
             */
            auto targetInfo = targetInfos[outputFile];
            if (targetInfo == nullptr) {
                LOG_S(DEBUG) << outputFile << " is treated as a target instead of an object file";
                auto targetObjectInfo = objectFileInfos[outputFile];
                auto tmpObjectFileName = createExplicitObjectFileCompilationCommand(targetObjectInfo);
                objectFileInfos.erase(outputFile);

                //create targetInfo
                targetInfo = targetInfos[outputFile] = std::make_shared<TargetInfo>();
                targetInfo->commands.emplace_back(
                    std::initializer_list<std::string>{ targetObjectInfo->command.getCompiler(),
                                                        "-o", outputFile, tmpObjectFileName },
                    directory);
                targetInfo->addFile(tmpObjectFileName);
            }
            //redirect new compilation command to temporary file
            auto tmpObjectFileName = createExplicitObjectFileCompilationCommand(objectInfo);

            //add new dependency to an implicit target
            targetInfo->commands[0].addFlagToEnd(tmpObjectFileName);
            targetInfo->addFile(tmpObjectFileName);
        } else {
            objectFileInfos[outputFile] = objectInfo;
        }
        const fs::path &sourcePath = objectInfo->getSourcePath();
        if (!CollectionUtils::containsKey(sourceFileInfos, sourcePath) ||
            conflictPriorityMore(objectInfo, fileCompileCommands[sourcePath].second)) {
            fileCompileCommands[sourcePath] = { compileCommand, objectInfo };
        }
        sourceFileInfos[sourcePath].emplace_back(objectInfo);
    }
    for (auto &[sourceFile, objectInfos]: sourceFileInfos) {
        std::sort(objectInfos.begin(), objectInfos.end(), conflictPriorityMore);
    }
    nlohmann::json compileCommandsSingleFilesJson;
    for (const auto &compileCommand: fileCompileCommands) {
        compileCommandsSingleFilesJson.push_back(compileCommand.second.first);
    }
    fs::path clangCompileCommandsJsonPath = CompilationUtils::getClangCompileCommandsJsonPath(buildCommandsJsonPath);
    JsonUtils::writeJsonToFile(clangCompileCommandsJsonPath, compileCommandsSingleFilesJson);
}

void BuildDatabase::initInfo(const nlohmann::json &linkCommandsJson) {
    for (nlohmann::json const &linkCommand : linkCommandsJson) {
        fs::path directory = linkCommand.at("directory").get<string>();
        std::vector<string> jsonArguments;
        if (linkCommand.contains("command")) {
            string command = linkCommand.at("command");
            jsonArguments = StringUtils::splitByWhitespaces(command);
        } else {
            jsonArguments = std::vector<string>(linkCommand.at("arguments"));
        }
        if (StringUtils::endsWith(jsonArguments[0], "ranlib") ||
            StringUtils::endsWith(jsonArguments[0], "cmake")) {
            continue;
        }
        std::transform(jsonArguments.begin(), jsonArguments.end(), jsonArguments.begin(),
                       [&directory](const string &argument) {
                         return tryConvertOptionToPath(argument, directory);
                       });

        mergeLibraryOptions(jsonArguments);

        utbot::LinkCommand command(jsonArguments, directory);
        fs::path const &output = command.getOutput();
        auto targetInfo = targetInfos[output];
        if (targetInfo == nullptr) {
            targetInfo = targetInfos[output] = std::make_shared<TargetInfo>();
        }
        for (nlohmann::json const &jsonFile : linkCommand.at("files")) {
            auto filename = jsonFile.get<std::string>();
            fs::path currentFile = Paths::getCCJsonFileFullPath(filename, command.getDirectory());
            targetInfo->addFile(currentFile);
            if (Paths::isObjectFile(currentFile)) {
                if (!CollectionUtils::containsKey(objectFileInfos, currentFile)) {
                    throw CompilationDatabaseException("compile_commands.json doesn't contain a command for object file "
                                                       + currentFile.string());
                }
                objectFileInfos[currentFile]->linkUnit = output;
            }
        }
        targetInfo->commands.emplace_back(command);
    }
}

void BuildDatabase::mergeLibraryOptions(std::vector<std::string> &jsonArguments) const {
    for (auto it = jsonArguments.begin(); it != jsonArguments.end(); it++) {
        if (*it == DynamicLibraryUtils::libraryDirOption || *it == DynamicLibraryUtils::linkFlag) {
            auto next = std::next(it);
            *it += *next;
            *next = "";
        }
    }
    CollectionUtils::erase(jsonArguments, "");
}

namespace {
    CollectionUtils::OrderedFileSet collectLibraryDirs(const utbot::BaseCommand *command) {
        using namespace DynamicLibraryUtils;
        CollectionUtils::OrderedFileSet libraryDirs;
        for (string const &argument : command->getCommandLine()) {
            auto optionalLibraryPath = getLibraryAbsolutePath(argument, command->getDirectory());
            if (optionalLibraryPath.has_value()) {
                libraryDirs.insert(optionalLibraryPath.value());
            }
            if (StringUtils::startsWith(argument, libraryDirOptionWl)) {
                auto commaSeparated = StringUtils::split(argument, ',');
                bool isRpathNext = false;
                for (auto part : commaSeparated) {
                    if (part == rpathFlag) {
                        isRpathNext = true;
                        continue;
                    }
                    if (isRpathNext) {
                        isRpathNext = false;
                        libraryDirs.insert(part);
                    }
                }
            }
        }
        return libraryDirs;
    }

    CollectionUtils::MapFileTo<string> collectLibraryNames(const utbot::BaseCommand *command) {
        using namespace DynamicLibraryUtils;

        CollectionUtils::MapFileTo<string> libraryNames;

        for (const auto &argument : command->getCommandLine()) {
            if (Paths::isSharedLibraryFile(argument) && argument != command->getOutput() &&
                !StringUtils::startsWith(argument, libraryDirOptionWl)) {
                libraryNames.emplace(argument, argument);
            }
            if (StringUtils::startsWith(argument, linkFlag)) {
                string libraryName = argument.substr(linkFlag.length());
                string archiveFile = "lib" + libraryName + ".a";
                string sharedObjectFile = "lib" + libraryName + ".so";
                libraryNames.emplace(sharedObjectFile, argument);
                libraryNames.emplace(archiveFile, argument);
            }
        }
        return libraryNames;
    }
}

template <typename Info>
void BuildDatabase::addLibrariesForCommand(utbot::BaseCommand *command,
                            const std::shared_ptr<Info> &info,
                            sharedLibrariesMap &sharedLibraryFiles,
                            bool objectFiles) {
    if (command->isArchiveCommand()) {
        return;
    }
    auto libraryDirs = collectLibraryDirs(command);
    auto libraryNames = collectLibraryNames(command);
    std::unordered_map<std::string, fs::path> argumentToFile;
    for (auto const &[libraryName, argument] : libraryNames) {
        fs::path name = libraryName;
        for (auto const &libraryDir : libraryDirs) {
            if (CollectionUtils::containsKey(sharedLibraryFiles, name)) {
                if (CollectionUtils::containsKey(sharedLibraryFiles.at(name), libraryDir)) {
                    name = sharedLibraryFiles.at(name).at(libraryDir);
                }
            }
            fs::path fullPath = Paths::getCCJsonFileFullPath(name, libraryDir);
            if (CollectionUtils::containsKey(targetInfos, fullPath)) {
                info->addFile(fullPath);
                LOG_IF_S(WARNING, objectFiles) << "Object file " << command->getOutput() << " has library dependencies: " << fullPath;
                argumentToFile[argument] = fullPath;
            }
        }
    }
    for (auto &argument : command->getCommandLine()) {
        if (CollectionUtils::containsKey(argumentToFile, argument)) {
            argument = argumentToFile[argument];
        }
    }
}

void BuildDatabase::addLocalSharedLibraries() {
    sharedLibrariesMap sharedLibraryFiles;
    for (const auto &[linkFile, linkUnit] : targetInfos) {
        if (Paths::isSharedLibraryFile(linkFile)) {
            auto withoutVersion = CompilationUtils::removeSharedLibraryVersion(linkFile);
            sharedLibraryFiles[withoutVersion.filename()][linkFile.parent_path()] = linkFile;
        }
    }
    for (auto &[linkFile, targetInfo] : targetInfos) {
        for (auto &command : targetInfo->commands) {
            addLibrariesForCommand(static_cast<utbot::BaseCommand*>(&command), targetInfo, sharedLibraryFiles);
        }
    }
    for (auto &[objectFile, objectInfo] : objectFileInfos) {
        addLibrariesForCommand(static_cast<utbot::BaseCommand*>(&objectInfo->command), objectInfo, sharedLibraryFiles, true);
    }
}

void BuildDatabase::fillTargetInfoParents() {
    CollectionUtils::MapFileTo<std::vector<fs::path>> parentTargets;
    for (const auto &[linkFile, linkUnit] : targetInfos) {
        for (const fs::path &dependencyFile : linkUnit->files) {
            if (Paths::isLibraryFile(dependencyFile)) {
                parentTargets[dependencyFile].emplace_back(linkFile);
            }
            if (Paths::isObjectFile(dependencyFile)) {
                objectFileTargets[dependencyFile].emplace_back(linkFile);
            }
        }
    }
    for (auto &[library, parents] : parentTargets) {
        if (!CollectionUtils::containsKey(targetInfos, library)) {
            throw CompilationDatabaseException(
                "link_commands.json doesn't contain a command for building library: " +
                library.string() + "\nReferenced from command for: " + (parents.empty() ? "none" : parents[0].string()));
        }
        targetInfos[library]->parentLinkUnits = std::move(parents);
    }
}

const fs::path &BuildDatabase::getCompileCommandsJson() {
    return compileCommandsJsonPath;
}

const fs::path &BuildDatabase::getLinkCommandsJson() {
    return linkCommandsJsonPath;
}

std::vector<std::shared_ptr<BuildDatabase::ObjectFileInfo>>
BuildDatabase::getAllCompileCommands() const {
    std::vector<std::shared_ptr<ObjectFileInfo>> result;
    for (auto &[file, compilationUnit] : objectFileInfos) {
        result.emplace_back(compilationUnit);
    }
    return result;
}

fs::path BuildDatabase::getObjectFile(const fs::path &sourceFile) const {
    if (!CollectionUtils::containsKey(sourceFileInfos, sourceFile)) {
        throw CompilationDatabaseException("Couldn't find object file for current source file " +
                                           sourceFile.string());
    }
    auto objectInfo = sourceFileInfos.at(sourceFile)[0];
    return objectInfo->getOutputFile();
}

CollectionUtils::FileSet BuildDatabase::getArchiveObjectFiles(const fs::path &archive) const {
    if (Paths::isGtest(archive)) {
        return {};
    }
    if (!CollectionUtils::containsKey(targetInfos, archive)) {
        throw CompilationDatabaseException(
            "Couldn't find current archive file linkage information for " + archive.string());
    }
    std::shared_ptr<TargetInfo> targetInfo = targetInfos.at(archive);
    CollectionUtils::FileSet result;
    for (const auto &file : targetInfo->files) {
        if (Paths::isLibraryFile(file)) {
            auto archiveObjectFiles = getArchiveObjectFiles(file);
            CollectionUtils::extend(result, archiveObjectFiles);
        } else {
            const fs::path &sourcePath = getClientCompilationUnitInfo(file)->getSourcePath();
            if (Paths::isSourceFile(sourcePath)) {
                result.insert(file);
            } else {
                LOG_S(WARNING) << "Skipping source file " << file;
            }
        }
    }
    return result;
}

fs::path BuildDatabase::getRootForSource(const fs::path& path) const {
    fs::path normalizedPath = Paths::normalizedTrimmed(path);
    if (Paths::isSourceFile(normalizedPath)) {
        if (!CollectionUtils::containsKey(sourceFileInfos, normalizedPath)) {
            throw CompilationDatabaseException("No executable or library found for current source file in link_commands.json: " + path.string());
        }
        auto const &sourceFileInfo = sourceFileInfos.at(normalizedPath);

        auto linkUnit = sourceFileInfo[0]->linkUnit;
        if (linkUnit.empty()) {
            throw CompilationDatabaseException("No executable or library found for current source file in link_commands.json: " + path.string());
        }
        return getRootForSource(linkUnit);
    } else {
        if (!CollectionUtils::containsKey(targetInfos, normalizedPath)) {
            throw CompilationDatabaseException("No executable or library found for current library in link_commands.json: " + path.string());
        }
        auto linkUnit = targetInfos.at(normalizedPath);
        if (!linkUnit->parentLinkUnits.empty()) {
            return getRootForSource(linkUnit->parentLinkUnits[0]);
        } else {
            return linkUnit->getOutput();
        }
    }
}

fs::path BuildDatabase::getBitcodeForSource(const fs::path &sourceFile) const {
    fs::path serverBuildObjectFilePath = newDirForFile(sourceFile);
    return Paths::addExtension(serverBuildObjectFilePath, ".bc");
}

fs::path BuildDatabase::getBitcodeFile(const fs::path &filepath) const {
    auto objectInfo = sourceFileInfos.find(filepath);
    if (objectInfo != sourceFileInfos.end()) {
        return getBitcodeForSource(objectInfo->second[0]->getSourcePath());
    } else {
        auto objectInfo = objectFileInfos.find(filepath);
        if (objectInfo != objectFileInfos.end()) {
            return getBitcodeForSource(objectInfo->second->getSourcePath());
        } else {
            auto targetInfo = targetInfos.find(filepath);
            if (targetInfo != targetInfos.end()) {
                fs::path movedFile = newDirForFile(filepath);
                return getCorrespondingBitcodeFile(movedFile);
            }
            return getCorrespondingBitcodeFile(filepath);
        }
    }
}

std::shared_ptr<const BuildDatabase::ObjectFileInfo>
BuildDatabase::getClientCompilationUnitInfo(const fs::path &filepath) const {
    if (Paths::isSourceFile(filepath)) {
        if (!CollectionUtils::contains(sourceFileInfos, filepath)) {
            throw CompilationDatabaseException("File not found in compilation_commands.json: " + filepath.string());
        }
        return sourceFileInfos.at(filepath)[0];
    } if (Paths::isObjectFile(filepath)) {
        if (!CollectionUtils::contains(objectFileInfos, filepath)) {
            throw CompilationDatabaseException("File not found in compilation_commands.json: " + filepath.string());
        }
        return objectFileInfos.at(filepath);
    }
    throw CompilationDatabaseException("File is not a compilation unit or an object file: " + filepath.string());
}

std::shared_ptr<const BuildDatabase::TargetInfo>
BuildDatabase::getClientLinkUnitInfo(const fs::path &filepath) const {
    if (Paths::isSourceFile(filepath)) {
        auto compilationInfo = getClientCompilationUnitInfo(filepath);
        return targetInfos.at(compilationInfo->linkUnit);
    }
    if (CollectionUtils::containsKey(targetInfos, filepath)) {
        return targetInfos.at(filepath);
    }
    throw CompilationDatabaseException("File is not in link_commands.json: " +
                                       filepath.string());
}

bool BuildDatabase::conflictPriorityMore(
    const std::shared_ptr<BuildDatabase::ObjectFileInfo> &left,
    const std::shared_ptr<BuildDatabase::ObjectFileInfo> &right) {
    if (StringUtils::contains(left->getOutputFile().string(), "64")) {
        return true;
    }
    if (StringUtils::contains(right->getOutputFile().string(), "64")) {
        return false;
    }
    return false;
}

fs::path BuildDatabase::getCorrespondingBitcodeFile(const fs::path &filepath) {
    return Paths::replaceExtension(filepath, ".bc");
}

bool BuildDatabase::isFirstObjectFileForSource(const fs::path &objectFilePath) const {
    fs::path sourceFile = getClientCompilationUnitInfo(objectFilePath)->getSourcePath();
    fs::path firstObjectFileForSource = getClientCompilationUnitInfo(sourceFile)->getOutputFile();
    return objectFilePath == firstObjectFileForSource;
}

BuildDatabase::KleeFilesInfo::KleeFilesInfo(fs::path kleeFile) : kleeFile(std::move(kleeFile)) {
    fs::create_directories(this->kleeFile.parent_path());
}

void BuildDatabase::KleeFilesInfo::setCorrectMethods(std::unordered_set<std::string> correctMethods) {
    this->correctMethods = std::move(correctMethods);
}

bool BuildDatabase::KleeFilesInfo::isCorrectMethod(const string &method) {
    if (allAreCorrect) {
        return true;
    }
    return CollectionUtils::contains(correctMethods, method);
}

fs::path BuildDatabase::KleeFilesInfo::getKleeFile() {
    return getKleeFile("");
}

fs::path BuildDatabase::KleeFilesInfo::getKleeBitcodeFile() {
    return getKleeBitcodeFile("");
}

fs::path BuildDatabase::KleeFilesInfo::getKleeFile(const std::string& methodName) {
    return kleeFile;
}

fs::path BuildDatabase::KleeFilesInfo::getKleeBitcodeFile(const std::string& methodName) {
    return getCorrespondingBitcodeFile(getKleeFile());
}

void BuildDatabase::KleeFilesInfo::setAllAreCorrect(bool allAreCorrect) {
    this->allAreCorrect = allAreCorrect;
}

fs::path const &BuildDatabase::ObjectFileInfo::getDirectory() const {
    return command.getDirectory();
}

fs::path BuildDatabase::ObjectFileInfo::getSourcePath() const {
    return command.getSourcePath();
}

fs::path BuildDatabase::ObjectFileInfo::getOutputFile() const {
    return command.getOutput();
}

void BuildDatabase::ObjectFileInfo::setOutputFile(const fs::path &file) {
    command.setOutput(file);
}

void BuildDatabase::ObjectFileInfo::addFile(fs::path file) {
    files.insert(std::move(file));
}

void BuildDatabase::TargetInfo::addFile(fs::path file) {
    files.insert(std::move(file));
}

fs::path BuildDatabase::TargetInfo::getOutput() const {
    return commands[0].getOutput();
}

CollectionUtils::FileSet BuildDatabase::getStubFiles(
    const std::shared_ptr<const BuildDatabase::TargetInfo> &linkUnitInfo) const {
    auto iterator = linkUnitToStubFiles.find(linkUnitInfo);
    if (iterator != linkUnitToStubFiles.end()) {
        return iterator->second;
    }
    return {};
}
void BuildDatabase::assignStubFilesToLinkUnit(
    std::shared_ptr<const BuildDatabase::TargetInfo> linkUnitInfo,
    CollectionUtils::FileSet stubs) {
    linkUnitToStubFiles.emplace(linkUnitInfo, std::move(stubs));
}

std::vector<std::shared_ptr<BuildDatabase::TargetInfo>> BuildDatabase::getRootTargets() const {
    return CollectionUtils::filterOut(
            CollectionUtils::getValues(targetInfos),
            [](const std::shared_ptr<const BuildDatabase::TargetInfo> &linkUnitInfo) {
                return !linkUnitInfo->parentLinkUnits.empty();
            });
}

std::vector<std::shared_ptr<BuildDatabase::TargetInfo>> BuildDatabase::getAllTargets() const {
    return CollectionUtils::getValues(targetInfos);
}

std::vector<std::shared_ptr<BuildDatabase::TargetInfo>>
BuildDatabase::getTargetsForSourceFile(const fs::path &sourceFilePath) const {
    CollectionUtils::MapFileTo<bool> cache;
    std::function<bool(fs::path const &)> containsSourceFilePath = [&](fs::path const &unitFile) {
        if (CollectionUtils::containsKey(cache, unitFile)) {
            return cache[unitFile];
        }
        if (Paths::isObjectFile(unitFile)) {
            auto compilationUnitInfo = getClientCompilationUnitInfo(unitFile);
            bool isSame = compilationUnitInfo->getSourcePath() == sourceFilePath;
            return cache[unitFile] = isSame;
        }
        auto linkUnitInfo = getClientLinkUnitInfo(unitFile);
        bool result = CollectionUtils::anyTrue(CollectionUtils::transform(
            linkUnitInfo->files, [&containsSourceFilePath](fs::path const &subFile) {
                return containsSourceFilePath(subFile);
            }));
        return cache[unitFile] = result;
    };

    auto rootTargets = getRootTargets();
    return CollectionUtils::filterOut(
            rootTargets, [&](const std::shared_ptr<const BuildDatabase::TargetInfo> &rootTarget) {
                return !containsSourceFilePath(rootTarget->getOutput());
            });
}

std::vector<fs::path>
BuildDatabase::autoTargetListForFile(const fs::path &sourceFilePath, const fs::path &objectFile) const {

    auto result = CollectionUtils::transformTo<std::vector<fs::path>>(getTargetsForSourceFile(sourceFilePath),
                                                                      [&](const std::shared_ptr<const BuildDatabase::TargetInfo> &targetInfo) {
                                                                          return targetInfo->getOutput();
                                                                      });
    std::vector<fs::path> parents;
    if (CollectionUtils::containsKey(objectFileTargets, objectFile)) {
        parents = objectFileTargets.at(objectFile);
    } else {
        LOG_S(WARNING) << "No link unit parents were found for an object file: " << objectFile;
    }
    result.insert(
            result.end(),
            std::make_move_iterator(parents.begin()),
            std::make_move_iterator(parents.end())
    );
    return result;
}

std::shared_ptr<BuildDatabase::TargetInfo> BuildDatabase::getPriorityTarget() const {
    CollectionUtils::MapFileTo<int> cache;
    std::function<int(fs::path const &)> numberOfSources = [&](fs::path const &unitFile) {
        if (CollectionUtils::containsKey(cache, unitFile)) {
            return cache[unitFile];
        }
        if (Paths::isObjectFile(unitFile)) {
            return 1;
        }
        auto linkUnitInfo = getClientLinkUnitInfo(unitFile);
        int result = 0;
        for (const fs::path &subFile : linkUnitInfo->files) {
            result += numberOfSources(subFile);
        }
        return cache[unitFile] = result;
    };

    auto rootTargets = getRootTargets();
    auto it = std::max_element(rootTargets.begin(), rootTargets.end(),
                               [&](std::shared_ptr<BuildDatabase::TargetInfo> a,
                                   std::shared_ptr<BuildDatabase::TargetInfo> b) {
                                   return numberOfSources(a->getOutput()) <
                                          numberOfSources(b->getOutput());
                               });
    return *it;
}
fs::path BuildDatabase::newDirForFile(const fs::path &file) const {
    fs::path base = Paths::longestCommonPrefixPath(this->projectContext.buildDir,
                                                   this->projectContext.projectPath);
    return Paths::createNewDirForFile(file, base, this->serverBuildDir);
}
