// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: testgen.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_testgen_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_testgen_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "util.pb.h"
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_testgen_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_testgen_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_testgen_2eproto;
namespace testsgen {
class AssertionRequest;
struct AssertionRequestDefaultTypeInternal;
extern AssertionRequestDefaultTypeInternal _AssertionRequest_default_instance_;
class ClassRequest;
struct ClassRequestDefaultTypeInternal;
extern ClassRequestDefaultTypeInternal _ClassRequest_default_instance_;
class CoverageAndResultsRequest;
struct CoverageAndResultsRequestDefaultTypeInternal;
extern CoverageAndResultsRequestDefaultTypeInternal _CoverageAndResultsRequest_default_instance_;
class CoverageAndResultsResponse;
struct CoverageAndResultsResponseDefaultTypeInternal;
extern CoverageAndResultsResponseDefaultTypeInternal _CoverageAndResultsResponse_default_instance_;
class DummyRequest;
struct DummyRequestDefaultTypeInternal;
extern DummyRequestDefaultTypeInternal _DummyRequest_default_instance_;
class DummyResponse;
struct DummyResponseDefaultTypeInternal;
extern DummyResponseDefaultTypeInternal _DummyResponse_default_instance_;
class FileCoverageSimplified;
struct FileCoverageSimplifiedDefaultTypeInternal;
extern FileCoverageSimplifiedDefaultTypeInternal _FileCoverageSimplified_default_instance_;
class FileRequest;
struct FileRequestDefaultTypeInternal;
extern FileRequestDefaultTypeInternal _FileRequest_default_instance_;
class FileTargetsRequest;
struct FileTargetsRequestDefaultTypeInternal;
extern FileTargetsRequestDefaultTypeInternal _FileTargetsRequest_default_instance_;
class FileTargetsResponse;
struct FileTargetsResponseDefaultTypeInternal;
extern FileTargetsResponseDefaultTypeInternal _FileTargetsResponse_default_instance_;
class FolderRequest;
struct FolderRequestDefaultTypeInternal;
extern FolderRequestDefaultTypeInternal _FolderRequest_default_instance_;
class FunctionRequest;
struct FunctionRequestDefaultTypeInternal;
extern FunctionRequestDefaultTypeInternal _FunctionRequest_default_instance_;
class FunctionTypeResponse;
struct FunctionTypeResponseDefaultTypeInternal;
extern FunctionTypeResponseDefaultTypeInternal _FunctionTypeResponse_default_instance_;
class HeartbeatResponse;
struct HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class LineRequest;
struct LineRequestDefaultTypeInternal;
extern LineRequestDefaultTypeInternal _LineRequest_default_instance_;
class LogChannelRequest;
struct LogChannelRequestDefaultTypeInternal;
extern LogChannelRequestDefaultTypeInternal _LogChannelRequest_default_instance_;
class LogEntry;
struct LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class PredicateRequest;
struct PredicateRequestDefaultTypeInternal;
extern PredicateRequestDefaultTypeInternal _PredicateRequest_default_instance_;
class ProjectConfigRequest;
struct ProjectConfigRequestDefaultTypeInternal;
extern ProjectConfigRequestDefaultTypeInternal _ProjectConfigRequest_default_instance_;
class ProjectConfigResponse;
struct ProjectConfigResponseDefaultTypeInternal;
extern ProjectConfigResponseDefaultTypeInternal _ProjectConfigResponse_default_instance_;
class ProjectContext;
struct ProjectContextDefaultTypeInternal;
extern ProjectContextDefaultTypeInternal _ProjectContext_default_instance_;
class ProjectRequest;
struct ProjectRequestDefaultTypeInternal;
extern ProjectRequestDefaultTypeInternal _ProjectRequest_default_instance_;
class ProjectTarget;
struct ProjectTargetDefaultTypeInternal;
extern ProjectTargetDefaultTypeInternal _ProjectTarget_default_instance_;
class ProjectTargetsRequest;
struct ProjectTargetsRequestDefaultTypeInternal;
extern ProjectTargetsRequestDefaultTypeInternal _ProjectTargetsRequest_default_instance_;
class ProjectTargetsResponse;
struct ProjectTargetsResponseDefaultTypeInternal;
extern ProjectTargetsResponseDefaultTypeInternal _ProjectTargetsResponse_default_instance_;
class RegisterClientRequest;
struct RegisterClientRequestDefaultTypeInternal;
extern RegisterClientRequestDefaultTypeInternal _RegisterClientRequest_default_instance_;
class RegisterClientResponse;
struct RegisterClientResponseDefaultTypeInternal;
extern RegisterClientResponseDefaultTypeInternal _RegisterClientResponse_default_instance_;
class SettingsContext;
struct SettingsContextDefaultTypeInternal;
extern SettingsContextDefaultTypeInternal _SettingsContext_default_instance_;
class SnippetRequest;
struct SnippetRequestDefaultTypeInternal;
extern SnippetRequestDefaultTypeInternal _SnippetRequest_default_instance_;
class SourceLine;
struct SourceLineDefaultTypeInternal;
extern SourceLineDefaultTypeInternal _SourceLine_default_instance_;
class StubsResponse;
struct StubsResponseDefaultTypeInternal;
extern StubsResponseDefaultTypeInternal _StubsResponse_default_instance_;
class TestFilter;
struct TestFilterDefaultTypeInternal;
extern TestFilterDefaultTypeInternal _TestFilter_default_instance_;
class TestResultObject;
struct TestResultObjectDefaultTypeInternal;
extern TestResultObjectDefaultTypeInternal _TestResultObject_default_instance_;
class TestsResponse;
struct TestsResponseDefaultTypeInternal;
extern TestsResponseDefaultTypeInternal _TestsResponse_default_instance_;
class VersionInfo;
struct VersionInfoDefaultTypeInternal;
extern VersionInfoDefaultTypeInternal _VersionInfo_default_instance_;
}  // namespace testsgen
PROTOBUF_NAMESPACE_OPEN
template<> ::testsgen::AssertionRequest* Arena::CreateMaybeMessage<::testsgen::AssertionRequest>(Arena*);
template<> ::testsgen::ClassRequest* Arena::CreateMaybeMessage<::testsgen::ClassRequest>(Arena*);
template<> ::testsgen::CoverageAndResultsRequest* Arena::CreateMaybeMessage<::testsgen::CoverageAndResultsRequest>(Arena*);
template<> ::testsgen::CoverageAndResultsResponse* Arena::CreateMaybeMessage<::testsgen::CoverageAndResultsResponse>(Arena*);
template<> ::testsgen::DummyRequest* Arena::CreateMaybeMessage<::testsgen::DummyRequest>(Arena*);
template<> ::testsgen::DummyResponse* Arena::CreateMaybeMessage<::testsgen::DummyResponse>(Arena*);
template<> ::testsgen::FileCoverageSimplified* Arena::CreateMaybeMessage<::testsgen::FileCoverageSimplified>(Arena*);
template<> ::testsgen::FileRequest* Arena::CreateMaybeMessage<::testsgen::FileRequest>(Arena*);
template<> ::testsgen::FileTargetsRequest* Arena::CreateMaybeMessage<::testsgen::FileTargetsRequest>(Arena*);
template<> ::testsgen::FileTargetsResponse* Arena::CreateMaybeMessage<::testsgen::FileTargetsResponse>(Arena*);
template<> ::testsgen::FolderRequest* Arena::CreateMaybeMessage<::testsgen::FolderRequest>(Arena*);
template<> ::testsgen::FunctionRequest* Arena::CreateMaybeMessage<::testsgen::FunctionRequest>(Arena*);
template<> ::testsgen::FunctionTypeResponse* Arena::CreateMaybeMessage<::testsgen::FunctionTypeResponse>(Arena*);
template<> ::testsgen::HeartbeatResponse* Arena::CreateMaybeMessage<::testsgen::HeartbeatResponse>(Arena*);
template<> ::testsgen::LineRequest* Arena::CreateMaybeMessage<::testsgen::LineRequest>(Arena*);
template<> ::testsgen::LogChannelRequest* Arena::CreateMaybeMessage<::testsgen::LogChannelRequest>(Arena*);
template<> ::testsgen::LogEntry* Arena::CreateMaybeMessage<::testsgen::LogEntry>(Arena*);
template<> ::testsgen::PredicateRequest* Arena::CreateMaybeMessage<::testsgen::PredicateRequest>(Arena*);
template<> ::testsgen::ProjectConfigRequest* Arena::CreateMaybeMessage<::testsgen::ProjectConfigRequest>(Arena*);
template<> ::testsgen::ProjectConfigResponse* Arena::CreateMaybeMessage<::testsgen::ProjectConfigResponse>(Arena*);
template<> ::testsgen::ProjectContext* Arena::CreateMaybeMessage<::testsgen::ProjectContext>(Arena*);
template<> ::testsgen::ProjectRequest* Arena::CreateMaybeMessage<::testsgen::ProjectRequest>(Arena*);
template<> ::testsgen::ProjectTarget* Arena::CreateMaybeMessage<::testsgen::ProjectTarget>(Arena*);
template<> ::testsgen::ProjectTargetsRequest* Arena::CreateMaybeMessage<::testsgen::ProjectTargetsRequest>(Arena*);
template<> ::testsgen::ProjectTargetsResponse* Arena::CreateMaybeMessage<::testsgen::ProjectTargetsResponse>(Arena*);
template<> ::testsgen::RegisterClientRequest* Arena::CreateMaybeMessage<::testsgen::RegisterClientRequest>(Arena*);
template<> ::testsgen::RegisterClientResponse* Arena::CreateMaybeMessage<::testsgen::RegisterClientResponse>(Arena*);
template<> ::testsgen::SettingsContext* Arena::CreateMaybeMessage<::testsgen::SettingsContext>(Arena*);
template<> ::testsgen::SnippetRequest* Arena::CreateMaybeMessage<::testsgen::SnippetRequest>(Arena*);
template<> ::testsgen::SourceLine* Arena::CreateMaybeMessage<::testsgen::SourceLine>(Arena*);
template<> ::testsgen::StubsResponse* Arena::CreateMaybeMessage<::testsgen::StubsResponse>(Arena*);
template<> ::testsgen::TestFilter* Arena::CreateMaybeMessage<::testsgen::TestFilter>(Arena*);
template<> ::testsgen::TestResultObject* Arena::CreateMaybeMessage<::testsgen::TestResultObject>(Arena*);
template<> ::testsgen::TestsResponse* Arena::CreateMaybeMessage<::testsgen::TestsResponse>(Arena*);
template<> ::testsgen::VersionInfo* Arena::CreateMaybeMessage<::testsgen::VersionInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace testsgen {

enum TestStatus : int {
  TEST_PASSED = 0,
  TEST_FAILED = 1,
  TEST_DEATH = 2,
  TEST_INTERRUPTED = 3,
  TestStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TestStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TestStatus_IsValid(int value);
constexpr TestStatus TestStatus_MIN = TEST_PASSED;
constexpr TestStatus TestStatus_MAX = TEST_INTERRUPTED;
constexpr int TestStatus_ARRAYSIZE = TestStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TestStatus_descriptor();
template<typename T>
inline const std::string& TestStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TestStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TestStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TestStatus_descriptor(), enum_t_value);
}
inline bool TestStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TestStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TestStatus>(
    TestStatus_descriptor(), name, value);
}
enum ConfigMode : int {
  CHECK = 0,
  CREATE_BUILD_DIR = 1,
  GENERATE_JSON_FILES = 2,
  ALL = 3,
  ConfigMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConfigMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConfigMode_IsValid(int value);
constexpr ConfigMode ConfigMode_MIN = CHECK;
constexpr ConfigMode ConfigMode_MAX = ALL;
constexpr int ConfigMode_ARRAYSIZE = ConfigMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConfigMode_descriptor();
template<typename T>
inline const std::string& ConfigMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConfigMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConfigMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConfigMode_descriptor(), enum_t_value);
}
inline bool ConfigMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConfigMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConfigMode>(
    ConfigMode_descriptor(), name, value);
}
enum ProjectConfigStatus : int {
  IS_OK = 0,
  BUILD_DIR_NOT_FOUND = 1,
  COMPILE_COMMANDS_JSON_NOT_FOUND = 2,
  LINK_COMMANDS_JSON_NOT_FOUND = 3,
  BUILD_DIR_CREATION_FAILED = 4,
  RUN_JSON_GENERATION_FAILED = 5,
  BUILD_DIR_SAME_AS_PROJECT = 6,
  ProjectConfigStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProjectConfigStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProjectConfigStatus_IsValid(int value);
constexpr ProjectConfigStatus ProjectConfigStatus_MIN = IS_OK;
constexpr ProjectConfigStatus ProjectConfigStatus_MAX = BUILD_DIR_SAME_AS_PROJECT;
constexpr int ProjectConfigStatus_ARRAYSIZE = ProjectConfigStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProjectConfigStatus_descriptor();
template<typename T>
inline const std::string& ProjectConfigStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProjectConfigStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProjectConfigStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProjectConfigStatus_descriptor(), enum_t_value);
}
inline bool ProjectConfigStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProjectConfigStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProjectConfigStatus>(
    ProjectConfigStatus_descriptor(), name, value);
}
// ===================================================================

class DummyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:testsgen.DummyRequest) */ {
 public:
  inline DummyRequest() : DummyRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DummyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DummyRequest(const DummyRequest& from);
  DummyRequest(DummyRequest&& from) noexcept
    : DummyRequest() {
    *this = ::std::move(from);
  }

  inline DummyRequest& operator=(const DummyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DummyRequest& operator=(DummyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DummyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DummyRequest* internal_default_instance() {
    return reinterpret_cast<const DummyRequest*>(
               &_DummyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DummyRequest& a, DummyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DummyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DummyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DummyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DummyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DummyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DummyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.DummyRequest";
  }
  protected:
  explicit DummyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:testsgen.DummyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class DummyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:testsgen.DummyResponse) */ {
 public:
  inline DummyResponse() : DummyResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DummyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DummyResponse(const DummyResponse& from);
  DummyResponse(DummyResponse&& from) noexcept
    : DummyResponse() {
    *this = ::std::move(from);
  }

  inline DummyResponse& operator=(const DummyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DummyResponse& operator=(DummyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DummyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DummyResponse* internal_default_instance() {
    return reinterpret_cast<const DummyResponse*>(
               &_DummyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DummyResponse& a, DummyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DummyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DummyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DummyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DummyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DummyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DummyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.DummyResponse";
  }
  protected:
  explicit DummyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:testsgen.DummyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class VersionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.VersionInfo) */ {
 public:
  inline VersionInfo() : VersionInfo(nullptr) {}
  ~VersionInfo() override;
  explicit PROTOBUF_CONSTEXPR VersionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VersionInfo(const VersionInfo& from);
  VersionInfo(VersionInfo&& from) noexcept
    : VersionInfo() {
    *this = ::std::move(from);
  }

  inline VersionInfo& operator=(const VersionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionInfo& operator=(VersionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VersionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VersionInfo* internal_default_instance() {
    return reinterpret_cast<const VersionInfo*>(
               &_VersionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(VersionInfo& a, VersionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VersionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VersionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VersionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VersionInfo& from) {
    VersionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.VersionInfo";
  }
  protected:
  explicit VersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:testsgen.VersionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class RegisterClientRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.RegisterClientRequest) */ {
 public:
  inline RegisterClientRequest() : RegisterClientRequest(nullptr) {}
  ~RegisterClientRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterClientRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterClientRequest(const RegisterClientRequest& from);
  RegisterClientRequest(RegisterClientRequest&& from) noexcept
    : RegisterClientRequest() {
    *this = ::std::move(from);
  }

  inline RegisterClientRequest& operator=(const RegisterClientRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterClientRequest& operator=(RegisterClientRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterClientRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterClientRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterClientRequest*>(
               &_RegisterClientRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RegisterClientRequest& a, RegisterClientRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterClientRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterClientRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterClientRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterClientRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterClientRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterClientRequest& from) {
    RegisterClientRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterClientRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.RegisterClientRequest";
  }
  protected:
  explicit RegisterClientRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // @@protoc_insertion_point(class_scope:testsgen.RegisterClientRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class RegisterClientResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.RegisterClientResponse) */ {
 public:
  inline RegisterClientResponse() : RegisterClientResponse(nullptr) {}
  ~RegisterClientResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterClientResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterClientResponse(const RegisterClientResponse& from);
  RegisterClientResponse(RegisterClientResponse&& from) noexcept
    : RegisterClientResponse() {
    *this = ::std::move(from);
  }

  inline RegisterClientResponse& operator=(const RegisterClientResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterClientResponse& operator=(RegisterClientResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterClientResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterClientResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterClientResponse*>(
               &_RegisterClientResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegisterClientResponse& a, RegisterClientResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterClientResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterClientResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterClientResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterClientResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterClientResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterClientResponse& from) {
    RegisterClientResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterClientResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.RegisterClientResponse";
  }
  protected:
  explicit RegisterClientResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsDuplicateFieldNumber = 1,
  };
  // bool isDuplicate = 1;
  void clear_isduplicate();
  bool isduplicate() const;
  void set_isduplicate(bool value);
  private:
  bool _internal_isduplicate() const;
  void _internal_set_isduplicate(bool value);
  public:

  // @@protoc_insertion_point(class_scope:testsgen.RegisterClientResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool isduplicate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class FunctionTypeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.FunctionTypeResponse) */ {
 public:
  inline FunctionTypeResponse() : FunctionTypeResponse(nullptr) {}
  ~FunctionTypeResponse() override;
  explicit PROTOBUF_CONSTEXPR FunctionTypeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionTypeResponse(const FunctionTypeResponse& from);
  FunctionTypeResponse(FunctionTypeResponse&& from) noexcept
    : FunctionTypeResponse() {
    *this = ::std::move(from);
  }

  inline FunctionTypeResponse& operator=(const FunctionTypeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionTypeResponse& operator=(FunctionTypeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionTypeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionTypeResponse* internal_default_instance() {
    return reinterpret_cast<const FunctionTypeResponse*>(
               &_FunctionTypeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FunctionTypeResponse& a, FunctionTypeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionTypeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionTypeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionTypeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionTypeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunctionTypeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FunctionTypeResponse& from) {
    FunctionTypeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionTypeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.FunctionTypeResponse";
  }
  protected:
  explicit FunctionTypeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidationTypeFieldNumber = 1,
  };
  // .testsgen.ValidationType validationType = 1;
  void clear_validationtype();
  ::testsgen::ValidationType validationtype() const;
  void set_validationtype(::testsgen::ValidationType value);
  private:
  ::testsgen::ValidationType _internal_validationtype() const;
  void _internal_set_validationtype(::testsgen::ValidationType value);
  public:

  // @@protoc_insertion_point(class_scope:testsgen.FunctionTypeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int validationtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class LogChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.LogChannelRequest) */ {
 public:
  inline LogChannelRequest() : LogChannelRequest(nullptr) {}
  ~LogChannelRequest() override;
  explicit PROTOBUF_CONSTEXPR LogChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogChannelRequest(const LogChannelRequest& from);
  LogChannelRequest(LogChannelRequest&& from) noexcept
    : LogChannelRequest() {
    *this = ::std::move(from);
  }

  inline LogChannelRequest& operator=(const LogChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogChannelRequest& operator=(LogChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogChannelRequest* internal_default_instance() {
    return reinterpret_cast<const LogChannelRequest*>(
               &_LogChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LogChannelRequest& a, LogChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogChannelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogChannelRequest& from) {
    LogChannelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.LogChannelRequest";
  }
  protected:
  explicit LogChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogLevelFieldNumber = 2,
  };
  // string logLevel = 2;
  void clear_loglevel();
  const std::string& loglevel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loglevel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loglevel();
  PROTOBUF_NODISCARD std::string* release_loglevel();
  void set_allocated_loglevel(std::string* loglevel);
  private:
  const std::string& _internal_loglevel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loglevel(const std::string& value);
  std::string* _internal_mutable_loglevel();
  public:

  // @@protoc_insertion_point(class_scope:testsgen.LogChannelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loglevel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class LogEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.LogEntry) */ {
 public:
  inline LogEntry() : LogEntry(nullptr) {}
  ~LogEntry() override;
  explicit PROTOBUF_CONSTEXPR LogEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogEntry(const LogEntry& from);
  LogEntry(LogEntry&& from) noexcept
    : LogEntry() {
    *this = ::std::move(from);
  }

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
               &_LogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LogEntry& a, LogEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(LogEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogEntry& from) {
    LogEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.LogEntry";
  }
  protected:
  explicit LogEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:testsgen.LogEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class ProjectContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.ProjectContext) */ {
 public:
  inline ProjectContext() : ProjectContext(nullptr) {}
  ~ProjectContext() override;
  explicit PROTOBUF_CONSTEXPR ProjectContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectContext(const ProjectContext& from);
  ProjectContext(ProjectContext&& from) noexcept
    : ProjectContext() {
    *this = ::std::move(from);
  }

  inline ProjectContext& operator=(const ProjectContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectContext& operator=(ProjectContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectContext* internal_default_instance() {
    return reinterpret_cast<const ProjectContext*>(
               &_ProjectContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProjectContext& a, ProjectContext& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProjectContext& from) {
    ProjectContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.ProjectContext";
  }
  protected:
  explicit ProjectContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectNameFieldNumber = 1,
    kProjectPathFieldNumber = 2,
    kTestDirPathFieldNumber = 3,
    kBuildDirRelativePathFieldNumber = 4,
  };
  // string projectName = 1;
  void clear_projectname();
  const std::string& projectname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_projectname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_projectname();
  PROTOBUF_NODISCARD std::string* release_projectname();
  void set_allocated_projectname(std::string* projectname);
  private:
  const std::string& _internal_projectname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_projectname(const std::string& value);
  std::string* _internal_mutable_projectname();
  public:

  // string projectPath = 2;
  void clear_projectpath();
  const std::string& projectpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_projectpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_projectpath();
  PROTOBUF_NODISCARD std::string* release_projectpath();
  void set_allocated_projectpath(std::string* projectpath);
  private:
  const std::string& _internal_projectpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_projectpath(const std::string& value);
  std::string* _internal_mutable_projectpath();
  public:

  // string testDirPath = 3;
  void clear_testdirpath();
  const std::string& testdirpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_testdirpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_testdirpath();
  PROTOBUF_NODISCARD std::string* release_testdirpath();
  void set_allocated_testdirpath(std::string* testdirpath);
  private:
  const std::string& _internal_testdirpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_testdirpath(const std::string& value);
  std::string* _internal_mutable_testdirpath();
  public:

  // string buildDirRelativePath = 4;
  void clear_builddirrelativepath();
  const std::string& builddirrelativepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_builddirrelativepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_builddirrelativepath();
  PROTOBUF_NODISCARD std::string* release_builddirrelativepath();
  void set_allocated_builddirrelativepath(std::string* builddirrelativepath);
  private:
  const std::string& _internal_builddirrelativepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_builddirrelativepath(const std::string& value);
  std::string* _internal_mutable_builddirrelativepath();
  public:

  // @@protoc_insertion_point(class_scope:testsgen.ProjectContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr projectname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr projectpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr testdirpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr builddirrelativepath_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class SettingsContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.SettingsContext) */ {
 public:
  inline SettingsContext() : SettingsContext(nullptr) {}
  ~SettingsContext() override;
  explicit PROTOBUF_CONSTEXPR SettingsContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SettingsContext(const SettingsContext& from);
  SettingsContext(SettingsContext&& from) noexcept
    : SettingsContext() {
    *this = ::std::move(from);
  }

  inline SettingsContext& operator=(const SettingsContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettingsContext& operator=(SettingsContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SettingsContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const SettingsContext* internal_default_instance() {
    return reinterpret_cast<const SettingsContext*>(
               &_SettingsContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SettingsContext& a, SettingsContext& b) {
    a.Swap(&b);
  }
  inline void Swap(SettingsContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SettingsContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SettingsContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SettingsContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SettingsContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SettingsContext& from) {
    SettingsContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettingsContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.SettingsContext";
  }
  protected:
  explicit SettingsContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeoutPerFunctionFieldNumber = 3,
    kGenerateForStaticFunctionsFieldNumber = 1,
    kVerboseFieldNumber = 2,
    kUseDeterministicSearcherFieldNumber = 5,
    kUseStubsFieldNumber = 6,
    kTimeoutPerTestFieldNumber = 4,
  };
  // int32 timeoutPerFunction = 3;
  void clear_timeoutperfunction();
  int32_t timeoutperfunction() const;
  void set_timeoutperfunction(int32_t value);
  private:
  int32_t _internal_timeoutperfunction() const;
  void _internal_set_timeoutperfunction(int32_t value);
  public:

  // bool generateForStaticFunctions = 1;
  void clear_generateforstaticfunctions();
  bool generateforstaticfunctions() const;
  void set_generateforstaticfunctions(bool value);
  private:
  bool _internal_generateforstaticfunctions() const;
  void _internal_set_generateforstaticfunctions(bool value);
  public:

  // bool verbose = 2;
  void clear_verbose();
  bool verbose() const;
  void set_verbose(bool value);
  private:
  bool _internal_verbose() const;
  void _internal_set_verbose(bool value);
  public:

  // bool useDeterministicSearcher = 5;
  void clear_usedeterministicsearcher();
  bool usedeterministicsearcher() const;
  void set_usedeterministicsearcher(bool value);
  private:
  bool _internal_usedeterministicsearcher() const;
  void _internal_set_usedeterministicsearcher(bool value);
  public:

  // bool useStubs = 6;
  void clear_usestubs();
  bool usestubs() const;
  void set_usestubs(bool value);
  private:
  bool _internal_usestubs() const;
  void _internal_set_usestubs(bool value);
  public:

  // int32 timeoutPerTest = 4;
  void clear_timeoutpertest();
  int32_t timeoutpertest() const;
  void set_timeoutpertest(int32_t value);
  private:
  int32_t _internal_timeoutpertest() const;
  void _internal_set_timeoutpertest(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:testsgen.SettingsContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t timeoutperfunction_;
    bool generateforstaticfunctions_;
    bool verbose_;
    bool usedeterministicsearcher_;
    bool usestubs_;
    int32_t timeoutpertest_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class SnippetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.SnippetRequest) */ {
 public:
  inline SnippetRequest() : SnippetRequest(nullptr) {}
  ~SnippetRequest() override;
  explicit PROTOBUF_CONSTEXPR SnippetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnippetRequest(const SnippetRequest& from);
  SnippetRequest(SnippetRequest&& from) noexcept
    : SnippetRequest() {
    *this = ::std::move(from);
  }

  inline SnippetRequest& operator=(const SnippetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnippetRequest& operator=(SnippetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnippetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnippetRequest* internal_default_instance() {
    return reinterpret_cast<const SnippetRequest*>(
               &_SnippetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SnippetRequest& a, SnippetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SnippetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnippetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnippetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnippetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnippetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnippetRequest& from) {
    SnippetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnippetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.SnippetRequest";
  }
  protected:
  explicit SnippetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 3,
    kProjectContextFieldNumber = 1,
    kSettingsContextFieldNumber = 2,
  };
  // string filePath = 3;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // .testsgen.ProjectContext projectContext = 1;
  bool has_projectcontext() const;
  private:
  bool _internal_has_projectcontext() const;
  public:
  void clear_projectcontext();
  const ::testsgen::ProjectContext& projectcontext() const;
  PROTOBUF_NODISCARD ::testsgen::ProjectContext* release_projectcontext();
  ::testsgen::ProjectContext* mutable_projectcontext();
  void set_allocated_projectcontext(::testsgen::ProjectContext* projectcontext);
  private:
  const ::testsgen::ProjectContext& _internal_projectcontext() const;
  ::testsgen::ProjectContext* _internal_mutable_projectcontext();
  public:
  void unsafe_arena_set_allocated_projectcontext(
      ::testsgen::ProjectContext* projectcontext);
  ::testsgen::ProjectContext* unsafe_arena_release_projectcontext();

  // .testsgen.SettingsContext settingsContext = 2;
  bool has_settingscontext() const;
  private:
  bool _internal_has_settingscontext() const;
  public:
  void clear_settingscontext();
  const ::testsgen::SettingsContext& settingscontext() const;
  PROTOBUF_NODISCARD ::testsgen::SettingsContext* release_settingscontext();
  ::testsgen::SettingsContext* mutable_settingscontext();
  void set_allocated_settingscontext(::testsgen::SettingsContext* settingscontext);
  private:
  const ::testsgen::SettingsContext& _internal_settingscontext() const;
  ::testsgen::SettingsContext* _internal_mutable_settingscontext();
  public:
  void unsafe_arena_set_allocated_settingscontext(
      ::testsgen::SettingsContext* settingscontext);
  ::testsgen::SettingsContext* unsafe_arena_release_settingscontext();

  // @@protoc_insertion_point(class_scope:testsgen.SnippetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    ::testsgen::ProjectContext* projectcontext_;
    ::testsgen::SettingsContext* settingscontext_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class ProjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.ProjectRequest) */ {
 public:
  inline ProjectRequest() : ProjectRequest(nullptr) {}
  ~ProjectRequest() override;
  explicit PROTOBUF_CONSTEXPR ProjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectRequest(const ProjectRequest& from);
  ProjectRequest(ProjectRequest&& from) noexcept
    : ProjectRequest() {
    *this = ::std::move(from);
  }

  inline ProjectRequest& operator=(const ProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectRequest& operator=(ProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectRequest* internal_default_instance() {
    return reinterpret_cast<const ProjectRequest*>(
               &_ProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ProjectRequest& a, ProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProjectRequest& from) {
    ProjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.ProjectRequest";
  }
  protected:
  explicit ProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcePathsFieldNumber = 3,
    kTargetPathFieldNumber = 5,
    kProjectContextFieldNumber = 1,
    kSettingsContextFieldNumber = 2,
    kSynchronizeCodeFieldNumber = 4,
  };
  // repeated string sourcePaths = 3;
  int sourcepaths_size() const;
  private:
  int _internal_sourcepaths_size() const;
  public:
  void clear_sourcepaths();
  const std::string& sourcepaths(int index) const;
  std::string* mutable_sourcepaths(int index);
  void set_sourcepaths(int index, const std::string& value);
  void set_sourcepaths(int index, std::string&& value);
  void set_sourcepaths(int index, const char* value);
  void set_sourcepaths(int index, const char* value, size_t size);
  std::string* add_sourcepaths();
  void add_sourcepaths(const std::string& value);
  void add_sourcepaths(std::string&& value);
  void add_sourcepaths(const char* value);
  void add_sourcepaths(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& sourcepaths() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_sourcepaths();
  private:
  const std::string& _internal_sourcepaths(int index) const;
  std::string* _internal_add_sourcepaths();
  public:

  // string targetPath = 5;
  void clear_targetpath();
  const std::string& targetpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targetpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targetpath();
  PROTOBUF_NODISCARD std::string* release_targetpath();
  void set_allocated_targetpath(std::string* targetpath);
  private:
  const std::string& _internal_targetpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targetpath(const std::string& value);
  std::string* _internal_mutable_targetpath();
  public:

  // .testsgen.ProjectContext projectContext = 1;
  bool has_projectcontext() const;
  private:
  bool _internal_has_projectcontext() const;
  public:
  void clear_projectcontext();
  const ::testsgen::ProjectContext& projectcontext() const;
  PROTOBUF_NODISCARD ::testsgen::ProjectContext* release_projectcontext();
  ::testsgen::ProjectContext* mutable_projectcontext();
  void set_allocated_projectcontext(::testsgen::ProjectContext* projectcontext);
  private:
  const ::testsgen::ProjectContext& _internal_projectcontext() const;
  ::testsgen::ProjectContext* _internal_mutable_projectcontext();
  public:
  void unsafe_arena_set_allocated_projectcontext(
      ::testsgen::ProjectContext* projectcontext);
  ::testsgen::ProjectContext* unsafe_arena_release_projectcontext();

  // .testsgen.SettingsContext settingsContext = 2;
  bool has_settingscontext() const;
  private:
  bool _internal_has_settingscontext() const;
  public:
  void clear_settingscontext();
  const ::testsgen::SettingsContext& settingscontext() const;
  PROTOBUF_NODISCARD ::testsgen::SettingsContext* release_settingscontext();
  ::testsgen::SettingsContext* mutable_settingscontext();
  void set_allocated_settingscontext(::testsgen::SettingsContext* settingscontext);
  private:
  const ::testsgen::SettingsContext& _internal_settingscontext() const;
  ::testsgen::SettingsContext* _internal_mutable_settingscontext();
  public:
  void unsafe_arena_set_allocated_settingscontext(
      ::testsgen::SettingsContext* settingscontext);
  ::testsgen::SettingsContext* unsafe_arena_release_settingscontext();

  // bool synchronizeCode = 4;
  void clear_synchronizecode();
  bool synchronizecode() const;
  void set_synchronizecode(bool value);
  private:
  bool _internal_synchronizecode() const;
  void _internal_set_synchronizecode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:testsgen.ProjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> sourcepaths_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetpath_;
    ::testsgen::ProjectContext* projectcontext_;
    ::testsgen::SettingsContext* settingscontext_;
    bool synchronizecode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class FileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.FileRequest) */ {
 public:
  inline FileRequest() : FileRequest(nullptr) {}
  ~FileRequest() override;
  explicit PROTOBUF_CONSTEXPR FileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileRequest(const FileRequest& from);
  FileRequest(FileRequest&& from) noexcept
    : FileRequest() {
    *this = ::std::move(from);
  }

  inline FileRequest& operator=(const FileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileRequest& operator=(FileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileRequest* internal_default_instance() {
    return reinterpret_cast<const FileRequest*>(
               &_FileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FileRequest& a, FileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileRequest& from) {
    FileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.FileRequest";
  }
  protected:
  explicit FileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 2,
    kProjectRequestFieldNumber = 1,
  };
  // string filePath = 2;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // .testsgen.ProjectRequest projectRequest = 1;
  bool has_projectrequest() const;
  private:
  bool _internal_has_projectrequest() const;
  public:
  void clear_projectrequest();
  const ::testsgen::ProjectRequest& projectrequest() const;
  PROTOBUF_NODISCARD ::testsgen::ProjectRequest* release_projectrequest();
  ::testsgen::ProjectRequest* mutable_projectrequest();
  void set_allocated_projectrequest(::testsgen::ProjectRequest* projectrequest);
  private:
  const ::testsgen::ProjectRequest& _internal_projectrequest() const;
  ::testsgen::ProjectRequest* _internal_mutable_projectrequest();
  public:
  void unsafe_arena_set_allocated_projectrequest(
      ::testsgen::ProjectRequest* projectrequest);
  ::testsgen::ProjectRequest* unsafe_arena_release_projectrequest();

  // @@protoc_insertion_point(class_scope:testsgen.FileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    ::testsgen::ProjectRequest* projectrequest_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class FolderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.FolderRequest) */ {
 public:
  inline FolderRequest() : FolderRequest(nullptr) {}
  ~FolderRequest() override;
  explicit PROTOBUF_CONSTEXPR FolderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FolderRequest(const FolderRequest& from);
  FolderRequest(FolderRequest&& from) noexcept
    : FolderRequest() {
    *this = ::std::move(from);
  }

  inline FolderRequest& operator=(const FolderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FolderRequest& operator=(FolderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FolderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FolderRequest* internal_default_instance() {
    return reinterpret_cast<const FolderRequest*>(
               &_FolderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(FolderRequest& a, FolderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FolderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FolderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FolderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FolderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FolderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FolderRequest& from) {
    FolderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FolderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.FolderRequest";
  }
  protected:
  explicit FolderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFolderPathFieldNumber = 2,
    kProjectRequestFieldNumber = 1,
  };
  // string folderPath = 2;
  void clear_folderpath();
  const std::string& folderpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_folderpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_folderpath();
  PROTOBUF_NODISCARD std::string* release_folderpath();
  void set_allocated_folderpath(std::string* folderpath);
  private:
  const std::string& _internal_folderpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_folderpath(const std::string& value);
  std::string* _internal_mutable_folderpath();
  public:

  // .testsgen.ProjectRequest projectRequest = 1;
  bool has_projectrequest() const;
  private:
  bool _internal_has_projectrequest() const;
  public:
  void clear_projectrequest();
  const ::testsgen::ProjectRequest& projectrequest() const;
  PROTOBUF_NODISCARD ::testsgen::ProjectRequest* release_projectrequest();
  ::testsgen::ProjectRequest* mutable_projectrequest();
  void set_allocated_projectrequest(::testsgen::ProjectRequest* projectrequest);
  private:
  const ::testsgen::ProjectRequest& _internal_projectrequest() const;
  ::testsgen::ProjectRequest* _internal_mutable_projectrequest();
  public:
  void unsafe_arena_set_allocated_projectrequest(
      ::testsgen::ProjectRequest* projectrequest);
  ::testsgen::ProjectRequest* unsafe_arena_release_projectrequest();

  // @@protoc_insertion_point(class_scope:testsgen.FolderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr folderpath_;
    ::testsgen::ProjectRequest* projectrequest_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class LineRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.LineRequest) */ {
 public:
  inline LineRequest() : LineRequest(nullptr) {}
  ~LineRequest() override;
  explicit PROTOBUF_CONSTEXPR LineRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LineRequest(const LineRequest& from);
  LineRequest(LineRequest&& from) noexcept
    : LineRequest() {
    *this = ::std::move(from);
  }

  inline LineRequest& operator=(const LineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineRequest& operator=(LineRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LineRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LineRequest* internal_default_instance() {
    return reinterpret_cast<const LineRequest*>(
               &_LineRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LineRequest& a, LineRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LineRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LineRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LineRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LineRequest& from) {
    LineRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.LineRequest";
  }
  protected:
  explicit LineRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectRequestFieldNumber = 1,
    kSourceInfoFieldNumber = 2,
  };
  // .testsgen.ProjectRequest projectRequest = 1;
  bool has_projectrequest() const;
  private:
  bool _internal_has_projectrequest() const;
  public:
  void clear_projectrequest();
  const ::testsgen::ProjectRequest& projectrequest() const;
  PROTOBUF_NODISCARD ::testsgen::ProjectRequest* release_projectrequest();
  ::testsgen::ProjectRequest* mutable_projectrequest();
  void set_allocated_projectrequest(::testsgen::ProjectRequest* projectrequest);
  private:
  const ::testsgen::ProjectRequest& _internal_projectrequest() const;
  ::testsgen::ProjectRequest* _internal_mutable_projectrequest();
  public:
  void unsafe_arena_set_allocated_projectrequest(
      ::testsgen::ProjectRequest* projectrequest);
  ::testsgen::ProjectRequest* unsafe_arena_release_projectrequest();

  // .testsgen.SourceInfo sourceInfo = 2;
  bool has_sourceinfo() const;
  private:
  bool _internal_has_sourceinfo() const;
  public:
  void clear_sourceinfo();
  const ::testsgen::SourceInfo& sourceinfo() const;
  PROTOBUF_NODISCARD ::testsgen::SourceInfo* release_sourceinfo();
  ::testsgen::SourceInfo* mutable_sourceinfo();
  void set_allocated_sourceinfo(::testsgen::SourceInfo* sourceinfo);
  private:
  const ::testsgen::SourceInfo& _internal_sourceinfo() const;
  ::testsgen::SourceInfo* _internal_mutable_sourceinfo();
  public:
  void unsafe_arena_set_allocated_sourceinfo(
      ::testsgen::SourceInfo* sourceinfo);
  ::testsgen::SourceInfo* unsafe_arena_release_sourceinfo();

  // @@protoc_insertion_point(class_scope:testsgen.LineRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::testsgen::ProjectRequest* projectrequest_;
    ::testsgen::SourceInfo* sourceinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class FunctionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.FunctionRequest) */ {
 public:
  inline FunctionRequest() : FunctionRequest(nullptr) {}
  ~FunctionRequest() override;
  explicit PROTOBUF_CONSTEXPR FunctionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionRequest(const FunctionRequest& from);
  FunctionRequest(FunctionRequest&& from) noexcept
    : FunctionRequest() {
    *this = ::std::move(from);
  }

  inline FunctionRequest& operator=(const FunctionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionRequest& operator=(FunctionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionRequest* internal_default_instance() {
    return reinterpret_cast<const FunctionRequest*>(
               &_FunctionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(FunctionRequest& a, FunctionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunctionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FunctionRequest& from) {
    FunctionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.FunctionRequest";
  }
  protected:
  explicit FunctionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineRequestFieldNumber = 1,
  };
  // .testsgen.LineRequest lineRequest = 1;
  bool has_linerequest() const;
  private:
  bool _internal_has_linerequest() const;
  public:
  void clear_linerequest();
  const ::testsgen::LineRequest& linerequest() const;
  PROTOBUF_NODISCARD ::testsgen::LineRequest* release_linerequest();
  ::testsgen::LineRequest* mutable_linerequest();
  void set_allocated_linerequest(::testsgen::LineRequest* linerequest);
  private:
  const ::testsgen::LineRequest& _internal_linerequest() const;
  ::testsgen::LineRequest* _internal_mutable_linerequest();
  public:
  void unsafe_arena_set_allocated_linerequest(
      ::testsgen::LineRequest* linerequest);
  ::testsgen::LineRequest* unsafe_arena_release_linerequest();

  // @@protoc_insertion_point(class_scope:testsgen.FunctionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::testsgen::LineRequest* linerequest_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class ClassRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.ClassRequest) */ {
 public:
  inline ClassRequest() : ClassRequest(nullptr) {}
  ~ClassRequest() override;
  explicit PROTOBUF_CONSTEXPR ClassRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClassRequest(const ClassRequest& from);
  ClassRequest(ClassRequest&& from) noexcept
    : ClassRequest() {
    *this = ::std::move(from);
  }

  inline ClassRequest& operator=(const ClassRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClassRequest& operator=(ClassRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClassRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClassRequest* internal_default_instance() {
    return reinterpret_cast<const ClassRequest*>(
               &_ClassRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ClassRequest& a, ClassRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClassRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClassRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClassRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClassRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClassRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClassRequest& from) {
    ClassRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.ClassRequest";
  }
  protected:
  explicit ClassRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineRequestFieldNumber = 1,
  };
  // .testsgen.LineRequest lineRequest = 1;
  bool has_linerequest() const;
  private:
  bool _internal_has_linerequest() const;
  public:
  void clear_linerequest();
  const ::testsgen::LineRequest& linerequest() const;
  PROTOBUF_NODISCARD ::testsgen::LineRequest* release_linerequest();
  ::testsgen::LineRequest* mutable_linerequest();
  void set_allocated_linerequest(::testsgen::LineRequest* linerequest);
  private:
  const ::testsgen::LineRequest& _internal_linerequest() const;
  ::testsgen::LineRequest* _internal_mutable_linerequest();
  public:
  void unsafe_arena_set_allocated_linerequest(
      ::testsgen::LineRequest* linerequest);
  ::testsgen::LineRequest* unsafe_arena_release_linerequest();

  // @@protoc_insertion_point(class_scope:testsgen.ClassRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::testsgen::LineRequest* linerequest_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class AssertionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.AssertionRequest) */ {
 public:
  inline AssertionRequest() : AssertionRequest(nullptr) {}
  ~AssertionRequest() override;
  explicit PROTOBUF_CONSTEXPR AssertionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssertionRequest(const AssertionRequest& from);
  AssertionRequest(AssertionRequest&& from) noexcept
    : AssertionRequest() {
    *this = ::std::move(from);
  }

  inline AssertionRequest& operator=(const AssertionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssertionRequest& operator=(AssertionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssertionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssertionRequest* internal_default_instance() {
    return reinterpret_cast<const AssertionRequest*>(
               &_AssertionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AssertionRequest& a, AssertionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AssertionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssertionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssertionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssertionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssertionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssertionRequest& from) {
    AssertionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssertionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.AssertionRequest";
  }
  protected:
  explicit AssertionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineRequestFieldNumber = 1,
  };
  // .testsgen.LineRequest lineRequest = 1;
  bool has_linerequest() const;
  private:
  bool _internal_has_linerequest() const;
  public:
  void clear_linerequest();
  const ::testsgen::LineRequest& linerequest() const;
  PROTOBUF_NODISCARD ::testsgen::LineRequest* release_linerequest();
  ::testsgen::LineRequest* mutable_linerequest();
  void set_allocated_linerequest(::testsgen::LineRequest* linerequest);
  private:
  const ::testsgen::LineRequest& _internal_linerequest() const;
  ::testsgen::LineRequest* _internal_mutable_linerequest();
  public:
  void unsafe_arena_set_allocated_linerequest(
      ::testsgen::LineRequest* linerequest);
  ::testsgen::LineRequest* unsafe_arena_release_linerequest();

  // @@protoc_insertion_point(class_scope:testsgen.AssertionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::testsgen::LineRequest* linerequest_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class PredicateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.PredicateRequest) */ {
 public:
  inline PredicateRequest() : PredicateRequest(nullptr) {}
  ~PredicateRequest() override;
  explicit PROTOBUF_CONSTEXPR PredicateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PredicateRequest(const PredicateRequest& from);
  PredicateRequest(PredicateRequest&& from) noexcept
    : PredicateRequest() {
    *this = ::std::move(from);
  }

  inline PredicateRequest& operator=(const PredicateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredicateRequest& operator=(PredicateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PredicateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PredicateRequest* internal_default_instance() {
    return reinterpret_cast<const PredicateRequest*>(
               &_PredicateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PredicateRequest& a, PredicateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PredicateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredicateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PredicateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PredicateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PredicateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PredicateRequest& from) {
    PredicateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredicateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.PredicateRequest";
  }
  protected:
  explicit PredicateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineRequestFieldNumber = 1,
    kPredicateInfoFieldNumber = 2,
  };
  // .testsgen.LineRequest lineRequest = 1;
  bool has_linerequest() const;
  private:
  bool _internal_has_linerequest() const;
  public:
  void clear_linerequest();
  const ::testsgen::LineRequest& linerequest() const;
  PROTOBUF_NODISCARD ::testsgen::LineRequest* release_linerequest();
  ::testsgen::LineRequest* mutable_linerequest();
  void set_allocated_linerequest(::testsgen::LineRequest* linerequest);
  private:
  const ::testsgen::LineRequest& _internal_linerequest() const;
  ::testsgen::LineRequest* _internal_mutable_linerequest();
  public:
  void unsafe_arena_set_allocated_linerequest(
      ::testsgen::LineRequest* linerequest);
  ::testsgen::LineRequest* unsafe_arena_release_linerequest();

  // .testsgen.PredicateInfo predicateInfo = 2;
  bool has_predicateinfo() const;
  private:
  bool _internal_has_predicateinfo() const;
  public:
  void clear_predicateinfo();
  const ::testsgen::PredicateInfo& predicateinfo() const;
  PROTOBUF_NODISCARD ::testsgen::PredicateInfo* release_predicateinfo();
  ::testsgen::PredicateInfo* mutable_predicateinfo();
  void set_allocated_predicateinfo(::testsgen::PredicateInfo* predicateinfo);
  private:
  const ::testsgen::PredicateInfo& _internal_predicateinfo() const;
  ::testsgen::PredicateInfo* _internal_mutable_predicateinfo();
  public:
  void unsafe_arena_set_allocated_predicateinfo(
      ::testsgen::PredicateInfo* predicateinfo);
  ::testsgen::PredicateInfo* unsafe_arena_release_predicateinfo();

  // @@protoc_insertion_point(class_scope:testsgen.PredicateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::testsgen::LineRequest* linerequest_;
    ::testsgen::PredicateInfo* predicateinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class StubsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.StubsResponse) */ {
 public:
  inline StubsResponse() : StubsResponse(nullptr) {}
  ~StubsResponse() override;
  explicit PROTOBUF_CONSTEXPR StubsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StubsResponse(const StubsResponse& from);
  StubsResponse(StubsResponse&& from) noexcept
    : StubsResponse() {
    *this = ::std::move(from);
  }

  inline StubsResponse& operator=(const StubsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StubsResponse& operator=(StubsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StubsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StubsResponse* internal_default_instance() {
    return reinterpret_cast<const StubsResponse*>(
               &_StubsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(StubsResponse& a, StubsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StubsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StubsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StubsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StubsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StubsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StubsResponse& from) {
    StubsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StubsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.StubsResponse";
  }
  protected:
  explicit StubsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStubSourcesFieldNumber = 1,
    kProgressFieldNumber = 2,
  };
  // repeated .testsgen.SourceCode stubSources = 1;
  int stubsources_size() const;
  private:
  int _internal_stubsources_size() const;
  public:
  void clear_stubsources();
  ::testsgen::SourceCode* mutable_stubsources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceCode >*
      mutable_stubsources();
  private:
  const ::testsgen::SourceCode& _internal_stubsources(int index) const;
  ::testsgen::SourceCode* _internal_add_stubsources();
  public:
  const ::testsgen::SourceCode& stubsources(int index) const;
  ::testsgen::SourceCode* add_stubsources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceCode >&
      stubsources() const;

  // .testsgen.Progress progress = 2;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  const ::testsgen::Progress& progress() const;
  PROTOBUF_NODISCARD ::testsgen::Progress* release_progress();
  ::testsgen::Progress* mutable_progress();
  void set_allocated_progress(::testsgen::Progress* progress);
  private:
  const ::testsgen::Progress& _internal_progress() const;
  ::testsgen::Progress* _internal_mutable_progress();
  public:
  void unsafe_arena_set_allocated_progress(
      ::testsgen::Progress* progress);
  ::testsgen::Progress* unsafe_arena_release_progress();

  // @@protoc_insertion_point(class_scope:testsgen.StubsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceCode > stubsources_;
    ::testsgen::Progress* progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class TestsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.TestsResponse) */ {
 public:
  inline TestsResponse() : TestsResponse(nullptr) {}
  ~TestsResponse() override;
  explicit PROTOBUF_CONSTEXPR TestsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestsResponse(const TestsResponse& from);
  TestsResponse(TestsResponse&& from) noexcept
    : TestsResponse() {
    *this = ::std::move(from);
  }

  inline TestsResponse& operator=(const TestsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestsResponse& operator=(TestsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestsResponse* internal_default_instance() {
    return reinterpret_cast<const TestsResponse*>(
               &_TestsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TestsResponse& a, TestsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TestsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestsResponse& from) {
    TestsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.TestsResponse";
  }
  protected:
  explicit TestsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestSourcesFieldNumber = 1,
    kStubsFieldNumber = 2,
    kProgressFieldNumber = 3,
  };
  // repeated .testsgen.SourceCode testSources = 1;
  int testsources_size() const;
  private:
  int _internal_testsources_size() const;
  public:
  void clear_testsources();
  ::testsgen::SourceCode* mutable_testsources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceCode >*
      mutable_testsources();
  private:
  const ::testsgen::SourceCode& _internal_testsources(int index) const;
  ::testsgen::SourceCode* _internal_add_testsources();
  public:
  const ::testsgen::SourceCode& testsources(int index) const;
  ::testsgen::SourceCode* add_testsources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceCode >&
      testsources() const;

  // .testsgen.StubsResponse stubs = 2;
  bool has_stubs() const;
  private:
  bool _internal_has_stubs() const;
  public:
  void clear_stubs();
  const ::testsgen::StubsResponse& stubs() const;
  PROTOBUF_NODISCARD ::testsgen::StubsResponse* release_stubs();
  ::testsgen::StubsResponse* mutable_stubs();
  void set_allocated_stubs(::testsgen::StubsResponse* stubs);
  private:
  const ::testsgen::StubsResponse& _internal_stubs() const;
  ::testsgen::StubsResponse* _internal_mutable_stubs();
  public:
  void unsafe_arena_set_allocated_stubs(
      ::testsgen::StubsResponse* stubs);
  ::testsgen::StubsResponse* unsafe_arena_release_stubs();

  // .testsgen.Progress progress = 3;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  const ::testsgen::Progress& progress() const;
  PROTOBUF_NODISCARD ::testsgen::Progress* release_progress();
  ::testsgen::Progress* mutable_progress();
  void set_allocated_progress(::testsgen::Progress* progress);
  private:
  const ::testsgen::Progress& _internal_progress() const;
  ::testsgen::Progress* _internal_mutable_progress();
  public:
  void unsafe_arena_set_allocated_progress(
      ::testsgen::Progress* progress);
  ::testsgen::Progress* unsafe_arena_release_progress();

  // @@protoc_insertion_point(class_scope:testsgen.TestsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceCode > testsources_;
    ::testsgen::StubsResponse* stubs_;
    ::testsgen::Progress* progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class SourceLine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.SourceLine) */ {
 public:
  inline SourceLine() : SourceLine(nullptr) {}
  ~SourceLine() override;
  explicit PROTOBUF_CONSTEXPR SourceLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SourceLine(const SourceLine& from);
  SourceLine(SourceLine&& from) noexcept
    : SourceLine() {
    *this = ::std::move(from);
  }

  inline SourceLine& operator=(const SourceLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceLine& operator=(SourceLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SourceLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const SourceLine* internal_default_instance() {
    return reinterpret_cast<const SourceLine*>(
               &_SourceLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SourceLine& a, SourceLine& b) {
    a.Swap(&b);
  }
  inline void Swap(SourceLine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SourceLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SourceLine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SourceLine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SourceLine& from) {
    SourceLine::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceLine* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.SourceLine";
  }
  protected:
  explicit SourceLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineFieldNumber = 1,
  };
  // uint32 line = 1;
  void clear_line();
  uint32_t line() const;
  void set_line(uint32_t value);
  private:
  uint32_t _internal_line() const;
  void _internal_set_line(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:testsgen.SourceLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t line_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class FileCoverageSimplified final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.FileCoverageSimplified) */ {
 public:
  inline FileCoverageSimplified() : FileCoverageSimplified(nullptr) {}
  ~FileCoverageSimplified() override;
  explicit PROTOBUF_CONSTEXPR FileCoverageSimplified(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileCoverageSimplified(const FileCoverageSimplified& from);
  FileCoverageSimplified(FileCoverageSimplified&& from) noexcept
    : FileCoverageSimplified() {
    *this = ::std::move(from);
  }

  inline FileCoverageSimplified& operator=(const FileCoverageSimplified& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileCoverageSimplified& operator=(FileCoverageSimplified&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileCoverageSimplified& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileCoverageSimplified* internal_default_instance() {
    return reinterpret_cast<const FileCoverageSimplified*>(
               &_FileCoverageSimplified_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(FileCoverageSimplified& a, FileCoverageSimplified& b) {
    a.Swap(&b);
  }
  inline void Swap(FileCoverageSimplified* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileCoverageSimplified* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileCoverageSimplified* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileCoverageSimplified>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileCoverageSimplified& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileCoverageSimplified& from) {
    FileCoverageSimplified::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileCoverageSimplified* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.FileCoverageSimplified";
  }
  protected:
  explicit FileCoverageSimplified(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFullCoverageLinesFieldNumber = 2,
    kPartialCoverageLinesFieldNumber = 3,
    kNoCoverageLinesFieldNumber = 4,
    kFilePathFieldNumber = 1,
  };
  // repeated .testsgen.SourceLine fullCoverageLines = 2;
  int fullcoveragelines_size() const;
  private:
  int _internal_fullcoveragelines_size() const;
  public:
  void clear_fullcoveragelines();
  ::testsgen::SourceLine* mutable_fullcoveragelines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine >*
      mutable_fullcoveragelines();
  private:
  const ::testsgen::SourceLine& _internal_fullcoveragelines(int index) const;
  ::testsgen::SourceLine* _internal_add_fullcoveragelines();
  public:
  const ::testsgen::SourceLine& fullcoveragelines(int index) const;
  ::testsgen::SourceLine* add_fullcoveragelines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine >&
      fullcoveragelines() const;

  // repeated .testsgen.SourceLine partialCoverageLines = 3;
  int partialcoveragelines_size() const;
  private:
  int _internal_partialcoveragelines_size() const;
  public:
  void clear_partialcoveragelines();
  ::testsgen::SourceLine* mutable_partialcoveragelines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine >*
      mutable_partialcoveragelines();
  private:
  const ::testsgen::SourceLine& _internal_partialcoveragelines(int index) const;
  ::testsgen::SourceLine* _internal_add_partialcoveragelines();
  public:
  const ::testsgen::SourceLine& partialcoveragelines(int index) const;
  ::testsgen::SourceLine* add_partialcoveragelines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine >&
      partialcoveragelines() const;

  // repeated .testsgen.SourceLine noCoverageLines = 4;
  int nocoveragelines_size() const;
  private:
  int _internal_nocoveragelines_size() const;
  public:
  void clear_nocoveragelines();
  ::testsgen::SourceLine* mutable_nocoveragelines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine >*
      mutable_nocoveragelines();
  private:
  const ::testsgen::SourceLine& _internal_nocoveragelines(int index) const;
  ::testsgen::SourceLine* _internal_add_nocoveragelines();
  public:
  const ::testsgen::SourceLine& nocoveragelines(int index) const;
  ::testsgen::SourceLine* add_nocoveragelines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine >&
      nocoveragelines() const;

  // string filePath = 1;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // @@protoc_insertion_point(class_scope:testsgen.FileCoverageSimplified)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine > fullcoveragelines_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine > partialcoveragelines_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine > nocoveragelines_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class TestFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.TestFilter) */ {
 public:
  inline TestFilter() : TestFilter(nullptr) {}
  ~TestFilter() override;
  explicit PROTOBUF_CONSTEXPR TestFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestFilter(const TestFilter& from);
  TestFilter(TestFilter&& from) noexcept
    : TestFilter() {
    *this = ::std::move(from);
  }

  inline TestFilter& operator=(const TestFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestFilter& operator=(TestFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestFilter* internal_default_instance() {
    return reinterpret_cast<const TestFilter*>(
               &_TestFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TestFilter& a, TestFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(TestFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestFilter& from) {
    TestFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.TestFilter";
  }
  protected:
  explicit TestFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFilePathFieldNumber = 1,
    kTestNameFieldNumber = 2,
    kTestSuiteFieldNumber = 3,
  };
  // string testFilePath = 1;
  void clear_testfilepath();
  const std::string& testfilepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_testfilepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_testfilepath();
  PROTOBUF_NODISCARD std::string* release_testfilepath();
  void set_allocated_testfilepath(std::string* testfilepath);
  private:
  const std::string& _internal_testfilepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_testfilepath(const std::string& value);
  std::string* _internal_mutable_testfilepath();
  public:

  // string testName = 2;
  void clear_testname();
  const std::string& testname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_testname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_testname();
  PROTOBUF_NODISCARD std::string* release_testname();
  void set_allocated_testname(std::string* testname);
  private:
  const std::string& _internal_testname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_testname(const std::string& value);
  std::string* _internal_mutable_testname();
  public:

  // string testSuite = 3;
  void clear_testsuite();
  const std::string& testsuite() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_testsuite(ArgT0&& arg0, ArgT... args);
  std::string* mutable_testsuite();
  PROTOBUF_NODISCARD std::string* release_testsuite();
  void set_allocated_testsuite(std::string* testsuite);
  private:
  const std::string& _internal_testsuite() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_testsuite(const std::string& value);
  std::string* _internal_mutable_testsuite();
  public:

  // @@protoc_insertion_point(class_scope:testsgen.TestFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr testfilepath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr testname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr testsuite_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class CoverageAndResultsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.CoverageAndResultsRequest) */ {
 public:
  inline CoverageAndResultsRequest() : CoverageAndResultsRequest(nullptr) {}
  ~CoverageAndResultsRequest() override;
  explicit PROTOBUF_CONSTEXPR CoverageAndResultsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoverageAndResultsRequest(const CoverageAndResultsRequest& from);
  CoverageAndResultsRequest(CoverageAndResultsRequest&& from) noexcept
    : CoverageAndResultsRequest() {
    *this = ::std::move(from);
  }

  inline CoverageAndResultsRequest& operator=(const CoverageAndResultsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoverageAndResultsRequest& operator=(CoverageAndResultsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoverageAndResultsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoverageAndResultsRequest* internal_default_instance() {
    return reinterpret_cast<const CoverageAndResultsRequest*>(
               &_CoverageAndResultsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CoverageAndResultsRequest& a, CoverageAndResultsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CoverageAndResultsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoverageAndResultsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoverageAndResultsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoverageAndResultsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoverageAndResultsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CoverageAndResultsRequest& from) {
    CoverageAndResultsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoverageAndResultsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.CoverageAndResultsRequest";
  }
  protected:
  explicit CoverageAndResultsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectContextFieldNumber = 1,
    kSettingsContextFieldNumber = 2,
    kTestFilterFieldNumber = 3,
    kCoverageFieldNumber = 4,
  };
  // .testsgen.ProjectContext projectContext = 1;
  bool has_projectcontext() const;
  private:
  bool _internal_has_projectcontext() const;
  public:
  void clear_projectcontext();
  const ::testsgen::ProjectContext& projectcontext() const;
  PROTOBUF_NODISCARD ::testsgen::ProjectContext* release_projectcontext();
  ::testsgen::ProjectContext* mutable_projectcontext();
  void set_allocated_projectcontext(::testsgen::ProjectContext* projectcontext);
  private:
  const ::testsgen::ProjectContext& _internal_projectcontext() const;
  ::testsgen::ProjectContext* _internal_mutable_projectcontext();
  public:
  void unsafe_arena_set_allocated_projectcontext(
      ::testsgen::ProjectContext* projectcontext);
  ::testsgen::ProjectContext* unsafe_arena_release_projectcontext();

  // .testsgen.SettingsContext settingsContext = 2;
  bool has_settingscontext() const;
  private:
  bool _internal_has_settingscontext() const;
  public:
  void clear_settingscontext();
  const ::testsgen::SettingsContext& settingscontext() const;
  PROTOBUF_NODISCARD ::testsgen::SettingsContext* release_settingscontext();
  ::testsgen::SettingsContext* mutable_settingscontext();
  void set_allocated_settingscontext(::testsgen::SettingsContext* settingscontext);
  private:
  const ::testsgen::SettingsContext& _internal_settingscontext() const;
  ::testsgen::SettingsContext* _internal_mutable_settingscontext();
  public:
  void unsafe_arena_set_allocated_settingscontext(
      ::testsgen::SettingsContext* settingscontext);
  ::testsgen::SettingsContext* unsafe_arena_release_settingscontext();

  // .testsgen.TestFilter testFilter = 3;
  bool has_testfilter() const;
  private:
  bool _internal_has_testfilter() const;
  public:
  void clear_testfilter();
  const ::testsgen::TestFilter& testfilter() const;
  PROTOBUF_NODISCARD ::testsgen::TestFilter* release_testfilter();
  ::testsgen::TestFilter* mutable_testfilter();
  void set_allocated_testfilter(::testsgen::TestFilter* testfilter);
  private:
  const ::testsgen::TestFilter& _internal_testfilter() const;
  ::testsgen::TestFilter* _internal_mutable_testfilter();
  public:
  void unsafe_arena_set_allocated_testfilter(
      ::testsgen::TestFilter* testfilter);
  ::testsgen::TestFilter* unsafe_arena_release_testfilter();

  // bool coverage = 4;
  void clear_coverage();
  bool coverage() const;
  void set_coverage(bool value);
  private:
  bool _internal_coverage() const;
  void _internal_set_coverage(bool value);
  public:

  // @@protoc_insertion_point(class_scope:testsgen.CoverageAndResultsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::testsgen::ProjectContext* projectcontext_;
    ::testsgen::SettingsContext* settingscontext_;
    ::testsgen::TestFilter* testfilter_;
    bool coverage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class TestResultObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.TestResultObject) */ {
 public:
  inline TestResultObject() : TestResultObject(nullptr) {}
  ~TestResultObject() override;
  explicit PROTOBUF_CONSTEXPR TestResultObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestResultObject(const TestResultObject& from);
  TestResultObject(TestResultObject&& from) noexcept
    : TestResultObject() {
    *this = ::std::move(from);
  }

  inline TestResultObject& operator=(const TestResultObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestResultObject& operator=(TestResultObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestResultObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestResultObject* internal_default_instance() {
    return reinterpret_cast<const TestResultObject*>(
               &_TestResultObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TestResultObject& a, TestResultObject& b) {
    a.Swap(&b);
  }
  inline void Swap(TestResultObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestResultObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestResultObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestResultObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestResultObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestResultObject& from) {
    TestResultObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestResultObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.TestResultObject";
  }
  protected:
  explicit TestResultObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFilePathFieldNumber = 1,
    kTestnameFieldNumber = 2,
    kOutputFieldNumber = 4,
    kExecutionTimeFieldNumber = 5,
    kStatusFieldNumber = 3,
  };
  // string testFilePath = 1;
  void clear_testfilepath();
  const std::string& testfilepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_testfilepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_testfilepath();
  PROTOBUF_NODISCARD std::string* release_testfilepath();
  void set_allocated_testfilepath(std::string* testfilepath);
  private:
  const std::string& _internal_testfilepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_testfilepath(const std::string& value);
  std::string* _internal_mutable_testfilepath();
  public:

  // string testname = 2;
  void clear_testname();
  const std::string& testname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_testname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_testname();
  PROTOBUF_NODISCARD std::string* release_testname();
  void set_allocated_testname(std::string* testname);
  private:
  const std::string& _internal_testname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_testname(const std::string& value);
  std::string* _internal_mutable_testname();
  public:

  // string output = 4;
  void clear_output();
  const std::string& output() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output();
  PROTOBUF_NODISCARD std::string* release_output();
  void set_allocated_output(std::string* output);
  private:
  const std::string& _internal_output() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output(const std::string& value);
  std::string* _internal_mutable_output();
  public:

  // .google.protobuf.Duration executionTime = 5;
  bool has_executiontime() const;
  private:
  bool _internal_has_executiontime() const;
  public:
  void clear_executiontime();
  const ::PROTOBUF_NAMESPACE_ID::Duration& executiontime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_executiontime();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_executiontime();
  void set_allocated_executiontime(::PROTOBUF_NAMESPACE_ID::Duration* executiontime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_executiontime() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_executiontime();
  public:
  void unsafe_arena_set_allocated_executiontime(
      ::PROTOBUF_NAMESPACE_ID::Duration* executiontime);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_executiontime();

  // .testsgen.TestStatus status = 3;
  void clear_status();
  ::testsgen::TestStatus status() const;
  void set_status(::testsgen::TestStatus value);
  private:
  ::testsgen::TestStatus _internal_status() const;
  void _internal_set_status(::testsgen::TestStatus value);
  public:

  // @@protoc_insertion_point(class_scope:testsgen.TestResultObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr testfilepath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr testname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_;
    ::PROTOBUF_NAMESPACE_ID::Duration* executiontime_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class CoverageAndResultsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.CoverageAndResultsResponse) */ {
 public:
  inline CoverageAndResultsResponse() : CoverageAndResultsResponse(nullptr) {}
  ~CoverageAndResultsResponse() override;
  explicit PROTOBUF_CONSTEXPR CoverageAndResultsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoverageAndResultsResponse(const CoverageAndResultsResponse& from);
  CoverageAndResultsResponse(CoverageAndResultsResponse&& from) noexcept
    : CoverageAndResultsResponse() {
    *this = ::std::move(from);
  }

  inline CoverageAndResultsResponse& operator=(const CoverageAndResultsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoverageAndResultsResponse& operator=(CoverageAndResultsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoverageAndResultsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoverageAndResultsResponse* internal_default_instance() {
    return reinterpret_cast<const CoverageAndResultsResponse*>(
               &_CoverageAndResultsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CoverageAndResultsResponse& a, CoverageAndResultsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CoverageAndResultsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoverageAndResultsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoverageAndResultsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoverageAndResultsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoverageAndResultsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CoverageAndResultsResponse& from) {
    CoverageAndResultsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoverageAndResultsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.CoverageAndResultsResponse";
  }
  protected:
  explicit CoverageAndResultsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestRunResultsFieldNumber = 1,
    kCoveragesFieldNumber = 2,
    kErrorMessageFieldNumber = 4,
    kProgressFieldNumber = 3,
  };
  // repeated .testsgen.TestResultObject testRunResults = 1;
  int testrunresults_size() const;
  private:
  int _internal_testrunresults_size() const;
  public:
  void clear_testrunresults();
  ::testsgen::TestResultObject* mutable_testrunresults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::TestResultObject >*
      mutable_testrunresults();
  private:
  const ::testsgen::TestResultObject& _internal_testrunresults(int index) const;
  ::testsgen::TestResultObject* _internal_add_testrunresults();
  public:
  const ::testsgen::TestResultObject& testrunresults(int index) const;
  ::testsgen::TestResultObject* add_testrunresults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::TestResultObject >&
      testrunresults() const;

  // repeated .testsgen.FileCoverageSimplified coverages = 2;
  int coverages_size() const;
  private:
  int _internal_coverages_size() const;
  public:
  void clear_coverages();
  ::testsgen::FileCoverageSimplified* mutable_coverages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::FileCoverageSimplified >*
      mutable_coverages();
  private:
  const ::testsgen::FileCoverageSimplified& _internal_coverages(int index) const;
  ::testsgen::FileCoverageSimplified* _internal_add_coverages();
  public:
  const ::testsgen::FileCoverageSimplified& coverages(int index) const;
  ::testsgen::FileCoverageSimplified* add_coverages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::FileCoverageSimplified >&
      coverages() const;

  // string errorMessage = 4;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_NODISCARD std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // .testsgen.Progress progress = 3;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  const ::testsgen::Progress& progress() const;
  PROTOBUF_NODISCARD ::testsgen::Progress* release_progress();
  ::testsgen::Progress* mutable_progress();
  void set_allocated_progress(::testsgen::Progress* progress);
  private:
  const ::testsgen::Progress& _internal_progress() const;
  ::testsgen::Progress* _internal_mutable_progress();
  public:
  void unsafe_arena_set_allocated_progress(
      ::testsgen::Progress* progress);
  ::testsgen::Progress* unsafe_arena_release_progress();

  // @@protoc_insertion_point(class_scope:testsgen.CoverageAndResultsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::TestResultObject > testrunresults_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::FileCoverageSimplified > coverages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
    ::testsgen::Progress* progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.HeartbeatResponse) */ {
 public:
  inline HeartbeatResponse() : HeartbeatResponse(nullptr) {}
  ~HeartbeatResponse() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatResponse(const HeartbeatResponse& from);
  HeartbeatResponse(HeartbeatResponse&& from) noexcept
    : HeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
               &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatResponse& from) {
    HeartbeatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.HeartbeatResponse";
  }
  protected:
  explicit HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkedFieldNumber = 1,
  };
  // bool linked = 1;
  void clear_linked();
  bool linked() const;
  void set_linked(bool value);
  private:
  bool _internal_linked() const;
  void _internal_set_linked(bool value);
  public:

  // @@protoc_insertion_point(class_scope:testsgen.HeartbeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool linked_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class ProjectConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.ProjectConfigRequest) */ {
 public:
  inline ProjectConfigRequest() : ProjectConfigRequest(nullptr) {}
  ~ProjectConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR ProjectConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectConfigRequest(const ProjectConfigRequest& from);
  ProjectConfigRequest(ProjectConfigRequest&& from) noexcept
    : ProjectConfigRequest() {
    *this = ::std::move(from);
  }

  inline ProjectConfigRequest& operator=(const ProjectConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectConfigRequest& operator=(ProjectConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectConfigRequest* internal_default_instance() {
    return reinterpret_cast<const ProjectConfigRequest*>(
               &_ProjectConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ProjectConfigRequest& a, ProjectConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProjectConfigRequest& from) {
    ProjectConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.ProjectConfigRequest";
  }
  protected:
  explicit ProjectConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmakeOptionsFieldNumber = 3,
    kProjectContextFieldNumber = 1,
    kConfigModeFieldNumber = 2,
  };
  // repeated string cmakeOptions = 3;
  int cmakeoptions_size() const;
  private:
  int _internal_cmakeoptions_size() const;
  public:
  void clear_cmakeoptions();
  const std::string& cmakeoptions(int index) const;
  std::string* mutable_cmakeoptions(int index);
  void set_cmakeoptions(int index, const std::string& value);
  void set_cmakeoptions(int index, std::string&& value);
  void set_cmakeoptions(int index, const char* value);
  void set_cmakeoptions(int index, const char* value, size_t size);
  std::string* add_cmakeoptions();
  void add_cmakeoptions(const std::string& value);
  void add_cmakeoptions(std::string&& value);
  void add_cmakeoptions(const char* value);
  void add_cmakeoptions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cmakeoptions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cmakeoptions();
  private:
  const std::string& _internal_cmakeoptions(int index) const;
  std::string* _internal_add_cmakeoptions();
  public:

  // .testsgen.ProjectContext projectContext = 1;
  bool has_projectcontext() const;
  private:
  bool _internal_has_projectcontext() const;
  public:
  void clear_projectcontext();
  const ::testsgen::ProjectContext& projectcontext() const;
  PROTOBUF_NODISCARD ::testsgen::ProjectContext* release_projectcontext();
  ::testsgen::ProjectContext* mutable_projectcontext();
  void set_allocated_projectcontext(::testsgen::ProjectContext* projectcontext);
  private:
  const ::testsgen::ProjectContext& _internal_projectcontext() const;
  ::testsgen::ProjectContext* _internal_mutable_projectcontext();
  public:
  void unsafe_arena_set_allocated_projectcontext(
      ::testsgen::ProjectContext* projectcontext);
  ::testsgen::ProjectContext* unsafe_arena_release_projectcontext();

  // .testsgen.ConfigMode configMode = 2;
  void clear_configmode();
  ::testsgen::ConfigMode configmode() const;
  void set_configmode(::testsgen::ConfigMode value);
  private:
  ::testsgen::ConfigMode _internal_configmode() const;
  void _internal_set_configmode(::testsgen::ConfigMode value);
  public:

  // @@protoc_insertion_point(class_scope:testsgen.ProjectConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cmakeoptions_;
    ::testsgen::ProjectContext* projectcontext_;
    int configmode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class ProjectConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.ProjectConfigResponse) */ {
 public:
  inline ProjectConfigResponse() : ProjectConfigResponse(nullptr) {}
  ~ProjectConfigResponse() override;
  explicit PROTOBUF_CONSTEXPR ProjectConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectConfigResponse(const ProjectConfigResponse& from);
  ProjectConfigResponse(ProjectConfigResponse&& from) noexcept
    : ProjectConfigResponse() {
    *this = ::std::move(from);
  }

  inline ProjectConfigResponse& operator=(const ProjectConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectConfigResponse& operator=(ProjectConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectConfigResponse* internal_default_instance() {
    return reinterpret_cast<const ProjectConfigResponse*>(
               &_ProjectConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ProjectConfigResponse& a, ProjectConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProjectConfigResponse& from) {
    ProjectConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.ProjectConfigResponse";
  }
  protected:
  explicit ProjectConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kProgressFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .testsgen.Progress progress = 3;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  const ::testsgen::Progress& progress() const;
  PROTOBUF_NODISCARD ::testsgen::Progress* release_progress();
  ::testsgen::Progress* mutable_progress();
  void set_allocated_progress(::testsgen::Progress* progress);
  private:
  const ::testsgen::Progress& _internal_progress() const;
  ::testsgen::Progress* _internal_mutable_progress();
  public:
  void unsafe_arena_set_allocated_progress(
      ::testsgen::Progress* progress);
  ::testsgen::Progress* unsafe_arena_release_progress();

  // .testsgen.ProjectConfigStatus type = 1;
  void clear_type();
  ::testsgen::ProjectConfigStatus type() const;
  void set_type(::testsgen::ProjectConfigStatus value);
  private:
  ::testsgen::ProjectConfigStatus _internal_type() const;
  void _internal_set_type(::testsgen::ProjectConfigStatus value);
  public:

  // @@protoc_insertion_point(class_scope:testsgen.ProjectConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::testsgen::Progress* progress_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class ProjectTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.ProjectTarget) */ {
 public:
  inline ProjectTarget() : ProjectTarget(nullptr) {}
  ~ProjectTarget() override;
  explicit PROTOBUF_CONSTEXPR ProjectTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectTarget(const ProjectTarget& from);
  ProjectTarget(ProjectTarget&& from) noexcept
    : ProjectTarget() {
    *this = ::std::move(from);
  }

  inline ProjectTarget& operator=(const ProjectTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectTarget& operator=(ProjectTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectTarget* internal_default_instance() {
    return reinterpret_cast<const ProjectTarget*>(
               &_ProjectTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ProjectTarget& a, ProjectTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProjectTarget& from) {
    ProjectTarget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.ProjectTarget";
  }
  protected:
  explicit ProjectTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPathFieldNumber = 2,
    kDescriptionFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:testsgen.ProjectTarget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class ProjectTargetsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.ProjectTargetsRequest) */ {
 public:
  inline ProjectTargetsRequest() : ProjectTargetsRequest(nullptr) {}
  ~ProjectTargetsRequest() override;
  explicit PROTOBUF_CONSTEXPR ProjectTargetsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectTargetsRequest(const ProjectTargetsRequest& from);
  ProjectTargetsRequest(ProjectTargetsRequest&& from) noexcept
    : ProjectTargetsRequest() {
    *this = ::std::move(from);
  }

  inline ProjectTargetsRequest& operator=(const ProjectTargetsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectTargetsRequest& operator=(ProjectTargetsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectTargetsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectTargetsRequest* internal_default_instance() {
    return reinterpret_cast<const ProjectTargetsRequest*>(
               &_ProjectTargetsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ProjectTargetsRequest& a, ProjectTargetsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectTargetsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectTargetsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectTargetsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectTargetsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectTargetsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProjectTargetsRequest& from) {
    ProjectTargetsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectTargetsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.ProjectTargetsRequest";
  }
  protected:
  explicit ProjectTargetsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectContextFieldNumber = 1,
  };
  // .testsgen.ProjectContext projectContext = 1;
  bool has_projectcontext() const;
  private:
  bool _internal_has_projectcontext() const;
  public:
  void clear_projectcontext();
  const ::testsgen::ProjectContext& projectcontext() const;
  PROTOBUF_NODISCARD ::testsgen::ProjectContext* release_projectcontext();
  ::testsgen::ProjectContext* mutable_projectcontext();
  void set_allocated_projectcontext(::testsgen::ProjectContext* projectcontext);
  private:
  const ::testsgen::ProjectContext& _internal_projectcontext() const;
  ::testsgen::ProjectContext* _internal_mutable_projectcontext();
  public:
  void unsafe_arena_set_allocated_projectcontext(
      ::testsgen::ProjectContext* projectcontext);
  ::testsgen::ProjectContext* unsafe_arena_release_projectcontext();

  // @@protoc_insertion_point(class_scope:testsgen.ProjectTargetsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::testsgen::ProjectContext* projectcontext_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class ProjectTargetsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.ProjectTargetsResponse) */ {
 public:
  inline ProjectTargetsResponse() : ProjectTargetsResponse(nullptr) {}
  ~ProjectTargetsResponse() override;
  explicit PROTOBUF_CONSTEXPR ProjectTargetsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectTargetsResponse(const ProjectTargetsResponse& from);
  ProjectTargetsResponse(ProjectTargetsResponse&& from) noexcept
    : ProjectTargetsResponse() {
    *this = ::std::move(from);
  }

  inline ProjectTargetsResponse& operator=(const ProjectTargetsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectTargetsResponse& operator=(ProjectTargetsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectTargetsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectTargetsResponse* internal_default_instance() {
    return reinterpret_cast<const ProjectTargetsResponse*>(
               &_ProjectTargetsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ProjectTargetsResponse& a, ProjectTargetsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectTargetsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectTargetsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectTargetsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectTargetsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectTargetsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProjectTargetsResponse& from) {
    ProjectTargetsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectTargetsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.ProjectTargetsResponse";
  }
  protected:
  explicit ProjectTargetsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsFieldNumber = 1,
    kPriorityTargetFieldNumber = 2,
  };
  // repeated .testsgen.ProjectTarget targets = 1;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::testsgen::ProjectTarget* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::ProjectTarget >*
      mutable_targets();
  private:
  const ::testsgen::ProjectTarget& _internal_targets(int index) const;
  ::testsgen::ProjectTarget* _internal_add_targets();
  public:
  const ::testsgen::ProjectTarget& targets(int index) const;
  ::testsgen::ProjectTarget* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::ProjectTarget >&
      targets() const;

  // .testsgen.ProjectTarget priorityTarget = 2;
  bool has_prioritytarget() const;
  private:
  bool _internal_has_prioritytarget() const;
  public:
  void clear_prioritytarget();
  const ::testsgen::ProjectTarget& prioritytarget() const;
  PROTOBUF_NODISCARD ::testsgen::ProjectTarget* release_prioritytarget();
  ::testsgen::ProjectTarget* mutable_prioritytarget();
  void set_allocated_prioritytarget(::testsgen::ProjectTarget* prioritytarget);
  private:
  const ::testsgen::ProjectTarget& _internal_prioritytarget() const;
  ::testsgen::ProjectTarget* _internal_mutable_prioritytarget();
  public:
  void unsafe_arena_set_allocated_prioritytarget(
      ::testsgen::ProjectTarget* prioritytarget);
  ::testsgen::ProjectTarget* unsafe_arena_release_prioritytarget();

  // @@protoc_insertion_point(class_scope:testsgen.ProjectTargetsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::ProjectTarget > targets_;
    ::testsgen::ProjectTarget* prioritytarget_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class FileTargetsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.FileTargetsRequest) */ {
 public:
  inline FileTargetsRequest() : FileTargetsRequest(nullptr) {}
  ~FileTargetsRequest() override;
  explicit PROTOBUF_CONSTEXPR FileTargetsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileTargetsRequest(const FileTargetsRequest& from);
  FileTargetsRequest(FileTargetsRequest&& from) noexcept
    : FileTargetsRequest() {
    *this = ::std::move(from);
  }

  inline FileTargetsRequest& operator=(const FileTargetsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileTargetsRequest& operator=(FileTargetsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileTargetsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileTargetsRequest* internal_default_instance() {
    return reinterpret_cast<const FileTargetsRequest*>(
               &_FileTargetsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(FileTargetsRequest& a, FileTargetsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FileTargetsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileTargetsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileTargetsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileTargetsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileTargetsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileTargetsRequest& from) {
    FileTargetsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTargetsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.FileTargetsRequest";
  }
  protected:
  explicit FileTargetsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kProjectContextFieldNumber = 2,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .testsgen.ProjectContext projectContext = 2;
  bool has_projectcontext() const;
  private:
  bool _internal_has_projectcontext() const;
  public:
  void clear_projectcontext();
  const ::testsgen::ProjectContext& projectcontext() const;
  PROTOBUF_NODISCARD ::testsgen::ProjectContext* release_projectcontext();
  ::testsgen::ProjectContext* mutable_projectcontext();
  void set_allocated_projectcontext(::testsgen::ProjectContext* projectcontext);
  private:
  const ::testsgen::ProjectContext& _internal_projectcontext() const;
  ::testsgen::ProjectContext* _internal_mutable_projectcontext();
  public:
  void unsafe_arena_set_allocated_projectcontext(
      ::testsgen::ProjectContext* projectcontext);
  ::testsgen::ProjectContext* unsafe_arena_release_projectcontext();

  // @@protoc_insertion_point(class_scope:testsgen.FileTargetsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::testsgen::ProjectContext* projectcontext_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// -------------------------------------------------------------------

class FileTargetsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:testsgen.FileTargetsResponse) */ {
 public:
  inline FileTargetsResponse() : FileTargetsResponse(nullptr) {}
  ~FileTargetsResponse() override;
  explicit PROTOBUF_CONSTEXPR FileTargetsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileTargetsResponse(const FileTargetsResponse& from);
  FileTargetsResponse(FileTargetsResponse&& from) noexcept
    : FileTargetsResponse() {
    *this = ::std::move(from);
  }

  inline FileTargetsResponse& operator=(const FileTargetsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileTargetsResponse& operator=(FileTargetsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileTargetsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileTargetsResponse* internal_default_instance() {
    return reinterpret_cast<const FileTargetsResponse*>(
               &_FileTargetsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(FileTargetsResponse& a, FileTargetsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FileTargetsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileTargetsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileTargetsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileTargetsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileTargetsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileTargetsResponse& from) {
    FileTargetsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTargetsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "testsgen.FileTargetsResponse";
  }
  protected:
  explicit FileTargetsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsFieldNumber = 1,
  };
  // repeated .testsgen.ProjectTarget targets = 1;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::testsgen::ProjectTarget* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::ProjectTarget >*
      mutable_targets();
  private:
  const ::testsgen::ProjectTarget& _internal_targets(int index) const;
  ::testsgen::ProjectTarget* _internal_add_targets();
  public:
  const ::testsgen::ProjectTarget& targets(int index) const;
  ::testsgen::ProjectTarget* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::ProjectTarget >&
      targets() const;

  // @@protoc_insertion_point(class_scope:testsgen.FileTargetsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::ProjectTarget > targets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_testgen_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DummyRequest

// -------------------------------------------------------------------

// DummyResponse

// -------------------------------------------------------------------

// VersionInfo

// string version = 1;
inline void VersionInfo::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& VersionInfo::version() const {
  // @@protoc_insertion_point(field_get:testsgen.VersionInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VersionInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.VersionInfo.version)
}
inline std::string* VersionInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:testsgen.VersionInfo.version)
  return _s;
}
inline const std::string& VersionInfo::_internal_version() const {
  return _impl_.version_.Get();
}
inline void VersionInfo::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* VersionInfo::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* VersionInfo::release_version() {
  // @@protoc_insertion_point(field_release:testsgen.VersionInfo.version)
  return _impl_.version_.Release();
}
inline void VersionInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.VersionInfo.version)
}

// -------------------------------------------------------------------

// RegisterClientRequest

// string clientId = 1;
inline void RegisterClientRequest::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& RegisterClientRequest::clientid() const {
  // @@protoc_insertion_point(field_get:testsgen.RegisterClientRequest.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterClientRequest::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.RegisterClientRequest.clientId)
}
inline std::string* RegisterClientRequest::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:testsgen.RegisterClientRequest.clientId)
  return _s;
}
inline const std::string& RegisterClientRequest::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void RegisterClientRequest::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterClientRequest::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterClientRequest::release_clientid() {
  // @@protoc_insertion_point(field_release:testsgen.RegisterClientRequest.clientId)
  return _impl_.clientid_.Release();
}
inline void RegisterClientRequest::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.RegisterClientRequest.clientId)
}

// -------------------------------------------------------------------

// RegisterClientResponse

// bool isDuplicate = 1;
inline void RegisterClientResponse::clear_isduplicate() {
  _impl_.isduplicate_ = false;
}
inline bool RegisterClientResponse::_internal_isduplicate() const {
  return _impl_.isduplicate_;
}
inline bool RegisterClientResponse::isduplicate() const {
  // @@protoc_insertion_point(field_get:testsgen.RegisterClientResponse.isDuplicate)
  return _internal_isduplicate();
}
inline void RegisterClientResponse::_internal_set_isduplicate(bool value) {
  
  _impl_.isduplicate_ = value;
}
inline void RegisterClientResponse::set_isduplicate(bool value) {
  _internal_set_isduplicate(value);
  // @@protoc_insertion_point(field_set:testsgen.RegisterClientResponse.isDuplicate)
}

// -------------------------------------------------------------------

// FunctionTypeResponse

// .testsgen.ValidationType validationType = 1;
inline void FunctionTypeResponse::clear_validationtype() {
  _impl_.validationtype_ = 0;
}
inline ::testsgen::ValidationType FunctionTypeResponse::_internal_validationtype() const {
  return static_cast< ::testsgen::ValidationType >(_impl_.validationtype_);
}
inline ::testsgen::ValidationType FunctionTypeResponse::validationtype() const {
  // @@protoc_insertion_point(field_get:testsgen.FunctionTypeResponse.validationType)
  return _internal_validationtype();
}
inline void FunctionTypeResponse::_internal_set_validationtype(::testsgen::ValidationType value) {
  
  _impl_.validationtype_ = value;
}
inline void FunctionTypeResponse::set_validationtype(::testsgen::ValidationType value) {
  _internal_set_validationtype(value);
  // @@protoc_insertion_point(field_set:testsgen.FunctionTypeResponse.validationType)
}

// -------------------------------------------------------------------

// LogChannelRequest

// string logLevel = 2;
inline void LogChannelRequest::clear_loglevel() {
  _impl_.loglevel_.ClearToEmpty();
}
inline const std::string& LogChannelRequest::loglevel() const {
  // @@protoc_insertion_point(field_get:testsgen.LogChannelRequest.logLevel)
  return _internal_loglevel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogChannelRequest::set_loglevel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loglevel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.LogChannelRequest.logLevel)
}
inline std::string* LogChannelRequest::mutable_loglevel() {
  std::string* _s = _internal_mutable_loglevel();
  // @@protoc_insertion_point(field_mutable:testsgen.LogChannelRequest.logLevel)
  return _s;
}
inline const std::string& LogChannelRequest::_internal_loglevel() const {
  return _impl_.loglevel_.Get();
}
inline void LogChannelRequest::_internal_set_loglevel(const std::string& value) {
  
  _impl_.loglevel_.Set(value, GetArenaForAllocation());
}
inline std::string* LogChannelRequest::_internal_mutable_loglevel() {
  
  return _impl_.loglevel_.Mutable(GetArenaForAllocation());
}
inline std::string* LogChannelRequest::release_loglevel() {
  // @@protoc_insertion_point(field_release:testsgen.LogChannelRequest.logLevel)
  return _impl_.loglevel_.Release();
}
inline void LogChannelRequest::set_allocated_loglevel(std::string* loglevel) {
  if (loglevel != nullptr) {
    
  } else {
    
  }
  _impl_.loglevel_.SetAllocated(loglevel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loglevel_.IsDefault()) {
    _impl_.loglevel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.LogChannelRequest.logLevel)
}

// -------------------------------------------------------------------

// LogEntry

// string message = 1;
inline void LogEntry::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LogEntry::message() const {
  // @@protoc_insertion_point(field_get:testsgen.LogEntry.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.LogEntry.message)
}
inline std::string* LogEntry::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:testsgen.LogEntry.message)
  return _s;
}
inline const std::string& LogEntry::_internal_message() const {
  return _impl_.message_.Get();
}
inline void LogEntry::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEntry::release_message() {
  // @@protoc_insertion_point(field_release:testsgen.LogEntry.message)
  return _impl_.message_.Release();
}
inline void LogEntry::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.LogEntry.message)
}

// -------------------------------------------------------------------

// ProjectContext

// string projectName = 1;
inline void ProjectContext::clear_projectname() {
  _impl_.projectname_.ClearToEmpty();
}
inline const std::string& ProjectContext::projectname() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectContext.projectName)
  return _internal_projectname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectContext::set_projectname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.projectname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.ProjectContext.projectName)
}
inline std::string* ProjectContext::mutable_projectname() {
  std::string* _s = _internal_mutable_projectname();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectContext.projectName)
  return _s;
}
inline const std::string& ProjectContext::_internal_projectname() const {
  return _impl_.projectname_.Get();
}
inline void ProjectContext::_internal_set_projectname(const std::string& value) {
  
  _impl_.projectname_.Set(value, GetArenaForAllocation());
}
inline std::string* ProjectContext::_internal_mutable_projectname() {
  
  return _impl_.projectname_.Mutable(GetArenaForAllocation());
}
inline std::string* ProjectContext::release_projectname() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectContext.projectName)
  return _impl_.projectname_.Release();
}
inline void ProjectContext::set_allocated_projectname(std::string* projectname) {
  if (projectname != nullptr) {
    
  } else {
    
  }
  _impl_.projectname_.SetAllocated(projectname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.projectname_.IsDefault()) {
    _impl_.projectname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectContext.projectName)
}

// string projectPath = 2;
inline void ProjectContext::clear_projectpath() {
  _impl_.projectpath_.ClearToEmpty();
}
inline const std::string& ProjectContext::projectpath() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectContext.projectPath)
  return _internal_projectpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectContext::set_projectpath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.projectpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.ProjectContext.projectPath)
}
inline std::string* ProjectContext::mutable_projectpath() {
  std::string* _s = _internal_mutable_projectpath();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectContext.projectPath)
  return _s;
}
inline const std::string& ProjectContext::_internal_projectpath() const {
  return _impl_.projectpath_.Get();
}
inline void ProjectContext::_internal_set_projectpath(const std::string& value) {
  
  _impl_.projectpath_.Set(value, GetArenaForAllocation());
}
inline std::string* ProjectContext::_internal_mutable_projectpath() {
  
  return _impl_.projectpath_.Mutable(GetArenaForAllocation());
}
inline std::string* ProjectContext::release_projectpath() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectContext.projectPath)
  return _impl_.projectpath_.Release();
}
inline void ProjectContext::set_allocated_projectpath(std::string* projectpath) {
  if (projectpath != nullptr) {
    
  } else {
    
  }
  _impl_.projectpath_.SetAllocated(projectpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.projectpath_.IsDefault()) {
    _impl_.projectpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectContext.projectPath)
}

// string testDirPath = 3;
inline void ProjectContext::clear_testdirpath() {
  _impl_.testdirpath_.ClearToEmpty();
}
inline const std::string& ProjectContext::testdirpath() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectContext.testDirPath)
  return _internal_testdirpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectContext::set_testdirpath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.testdirpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.ProjectContext.testDirPath)
}
inline std::string* ProjectContext::mutable_testdirpath() {
  std::string* _s = _internal_mutable_testdirpath();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectContext.testDirPath)
  return _s;
}
inline const std::string& ProjectContext::_internal_testdirpath() const {
  return _impl_.testdirpath_.Get();
}
inline void ProjectContext::_internal_set_testdirpath(const std::string& value) {
  
  _impl_.testdirpath_.Set(value, GetArenaForAllocation());
}
inline std::string* ProjectContext::_internal_mutable_testdirpath() {
  
  return _impl_.testdirpath_.Mutable(GetArenaForAllocation());
}
inline std::string* ProjectContext::release_testdirpath() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectContext.testDirPath)
  return _impl_.testdirpath_.Release();
}
inline void ProjectContext::set_allocated_testdirpath(std::string* testdirpath) {
  if (testdirpath != nullptr) {
    
  } else {
    
  }
  _impl_.testdirpath_.SetAllocated(testdirpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.testdirpath_.IsDefault()) {
    _impl_.testdirpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectContext.testDirPath)
}

// string buildDirRelativePath = 4;
inline void ProjectContext::clear_builddirrelativepath() {
  _impl_.builddirrelativepath_.ClearToEmpty();
}
inline const std::string& ProjectContext::builddirrelativepath() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectContext.buildDirRelativePath)
  return _internal_builddirrelativepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectContext::set_builddirrelativepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.builddirrelativepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.ProjectContext.buildDirRelativePath)
}
inline std::string* ProjectContext::mutable_builddirrelativepath() {
  std::string* _s = _internal_mutable_builddirrelativepath();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectContext.buildDirRelativePath)
  return _s;
}
inline const std::string& ProjectContext::_internal_builddirrelativepath() const {
  return _impl_.builddirrelativepath_.Get();
}
inline void ProjectContext::_internal_set_builddirrelativepath(const std::string& value) {
  
  _impl_.builddirrelativepath_.Set(value, GetArenaForAllocation());
}
inline std::string* ProjectContext::_internal_mutable_builddirrelativepath() {
  
  return _impl_.builddirrelativepath_.Mutable(GetArenaForAllocation());
}
inline std::string* ProjectContext::release_builddirrelativepath() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectContext.buildDirRelativePath)
  return _impl_.builddirrelativepath_.Release();
}
inline void ProjectContext::set_allocated_builddirrelativepath(std::string* builddirrelativepath) {
  if (builddirrelativepath != nullptr) {
    
  } else {
    
  }
  _impl_.builddirrelativepath_.SetAllocated(builddirrelativepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.builddirrelativepath_.IsDefault()) {
    _impl_.builddirrelativepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectContext.buildDirRelativePath)
}

// -------------------------------------------------------------------

// SettingsContext

// bool generateForStaticFunctions = 1;
inline void SettingsContext::clear_generateforstaticfunctions() {
  _impl_.generateforstaticfunctions_ = false;
}
inline bool SettingsContext::_internal_generateforstaticfunctions() const {
  return _impl_.generateforstaticfunctions_;
}
inline bool SettingsContext::generateforstaticfunctions() const {
  // @@protoc_insertion_point(field_get:testsgen.SettingsContext.generateForStaticFunctions)
  return _internal_generateforstaticfunctions();
}
inline void SettingsContext::_internal_set_generateforstaticfunctions(bool value) {
  
  _impl_.generateforstaticfunctions_ = value;
}
inline void SettingsContext::set_generateforstaticfunctions(bool value) {
  _internal_set_generateforstaticfunctions(value);
  // @@protoc_insertion_point(field_set:testsgen.SettingsContext.generateForStaticFunctions)
}

// bool verbose = 2;
inline void SettingsContext::clear_verbose() {
  _impl_.verbose_ = false;
}
inline bool SettingsContext::_internal_verbose() const {
  return _impl_.verbose_;
}
inline bool SettingsContext::verbose() const {
  // @@protoc_insertion_point(field_get:testsgen.SettingsContext.verbose)
  return _internal_verbose();
}
inline void SettingsContext::_internal_set_verbose(bool value) {
  
  _impl_.verbose_ = value;
}
inline void SettingsContext::set_verbose(bool value) {
  _internal_set_verbose(value);
  // @@protoc_insertion_point(field_set:testsgen.SettingsContext.verbose)
}

// int32 timeoutPerFunction = 3;
inline void SettingsContext::clear_timeoutperfunction() {
  _impl_.timeoutperfunction_ = 0;
}
inline int32_t SettingsContext::_internal_timeoutperfunction() const {
  return _impl_.timeoutperfunction_;
}
inline int32_t SettingsContext::timeoutperfunction() const {
  // @@protoc_insertion_point(field_get:testsgen.SettingsContext.timeoutPerFunction)
  return _internal_timeoutperfunction();
}
inline void SettingsContext::_internal_set_timeoutperfunction(int32_t value) {
  
  _impl_.timeoutperfunction_ = value;
}
inline void SettingsContext::set_timeoutperfunction(int32_t value) {
  _internal_set_timeoutperfunction(value);
  // @@protoc_insertion_point(field_set:testsgen.SettingsContext.timeoutPerFunction)
}

// int32 timeoutPerTest = 4;
inline void SettingsContext::clear_timeoutpertest() {
  _impl_.timeoutpertest_ = 0;
}
inline int32_t SettingsContext::_internal_timeoutpertest() const {
  return _impl_.timeoutpertest_;
}
inline int32_t SettingsContext::timeoutpertest() const {
  // @@protoc_insertion_point(field_get:testsgen.SettingsContext.timeoutPerTest)
  return _internal_timeoutpertest();
}
inline void SettingsContext::_internal_set_timeoutpertest(int32_t value) {
  
  _impl_.timeoutpertest_ = value;
}
inline void SettingsContext::set_timeoutpertest(int32_t value) {
  _internal_set_timeoutpertest(value);
  // @@protoc_insertion_point(field_set:testsgen.SettingsContext.timeoutPerTest)
}

// bool useDeterministicSearcher = 5;
inline void SettingsContext::clear_usedeterministicsearcher() {
  _impl_.usedeterministicsearcher_ = false;
}
inline bool SettingsContext::_internal_usedeterministicsearcher() const {
  return _impl_.usedeterministicsearcher_;
}
inline bool SettingsContext::usedeterministicsearcher() const {
  // @@protoc_insertion_point(field_get:testsgen.SettingsContext.useDeterministicSearcher)
  return _internal_usedeterministicsearcher();
}
inline void SettingsContext::_internal_set_usedeterministicsearcher(bool value) {
  
  _impl_.usedeterministicsearcher_ = value;
}
inline void SettingsContext::set_usedeterministicsearcher(bool value) {
  _internal_set_usedeterministicsearcher(value);
  // @@protoc_insertion_point(field_set:testsgen.SettingsContext.useDeterministicSearcher)
}

// bool useStubs = 6;
inline void SettingsContext::clear_usestubs() {
  _impl_.usestubs_ = false;
}
inline bool SettingsContext::_internal_usestubs() const {
  return _impl_.usestubs_;
}
inline bool SettingsContext::usestubs() const {
  // @@protoc_insertion_point(field_get:testsgen.SettingsContext.useStubs)
  return _internal_usestubs();
}
inline void SettingsContext::_internal_set_usestubs(bool value) {
  
  _impl_.usestubs_ = value;
}
inline void SettingsContext::set_usestubs(bool value) {
  _internal_set_usestubs(value);
  // @@protoc_insertion_point(field_set:testsgen.SettingsContext.useStubs)
}

// -------------------------------------------------------------------

// SnippetRequest

// .testsgen.ProjectContext projectContext = 1;
inline bool SnippetRequest::_internal_has_projectcontext() const {
  return this != internal_default_instance() && _impl_.projectcontext_ != nullptr;
}
inline bool SnippetRequest::has_projectcontext() const {
  return _internal_has_projectcontext();
}
inline void SnippetRequest::clear_projectcontext() {
  if (GetArenaForAllocation() == nullptr && _impl_.projectcontext_ != nullptr) {
    delete _impl_.projectcontext_;
  }
  _impl_.projectcontext_ = nullptr;
}
inline const ::testsgen::ProjectContext& SnippetRequest::_internal_projectcontext() const {
  const ::testsgen::ProjectContext* p = _impl_.projectcontext_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::ProjectContext&>(
      ::testsgen::_ProjectContext_default_instance_);
}
inline const ::testsgen::ProjectContext& SnippetRequest::projectcontext() const {
  // @@protoc_insertion_point(field_get:testsgen.SnippetRequest.projectContext)
  return _internal_projectcontext();
}
inline void SnippetRequest::unsafe_arena_set_allocated_projectcontext(
    ::testsgen::ProjectContext* projectcontext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectcontext_);
  }
  _impl_.projectcontext_ = projectcontext;
  if (projectcontext) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.SnippetRequest.projectContext)
}
inline ::testsgen::ProjectContext* SnippetRequest::release_projectcontext() {
  
  ::testsgen::ProjectContext* temp = _impl_.projectcontext_;
  _impl_.projectcontext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::ProjectContext* SnippetRequest::unsafe_arena_release_projectcontext() {
  // @@protoc_insertion_point(field_release:testsgen.SnippetRequest.projectContext)
  
  ::testsgen::ProjectContext* temp = _impl_.projectcontext_;
  _impl_.projectcontext_ = nullptr;
  return temp;
}
inline ::testsgen::ProjectContext* SnippetRequest::_internal_mutable_projectcontext() {
  
  if (_impl_.projectcontext_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::ProjectContext>(GetArenaForAllocation());
    _impl_.projectcontext_ = p;
  }
  return _impl_.projectcontext_;
}
inline ::testsgen::ProjectContext* SnippetRequest::mutable_projectcontext() {
  ::testsgen::ProjectContext* _msg = _internal_mutable_projectcontext();
  // @@protoc_insertion_point(field_mutable:testsgen.SnippetRequest.projectContext)
  return _msg;
}
inline void SnippetRequest::set_allocated_projectcontext(::testsgen::ProjectContext* projectcontext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.projectcontext_;
  }
  if (projectcontext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(projectcontext);
    if (message_arena != submessage_arena) {
      projectcontext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projectcontext, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.projectcontext_ = projectcontext;
  // @@protoc_insertion_point(field_set_allocated:testsgen.SnippetRequest.projectContext)
}

// .testsgen.SettingsContext settingsContext = 2;
inline bool SnippetRequest::_internal_has_settingscontext() const {
  return this != internal_default_instance() && _impl_.settingscontext_ != nullptr;
}
inline bool SnippetRequest::has_settingscontext() const {
  return _internal_has_settingscontext();
}
inline void SnippetRequest::clear_settingscontext() {
  if (GetArenaForAllocation() == nullptr && _impl_.settingscontext_ != nullptr) {
    delete _impl_.settingscontext_;
  }
  _impl_.settingscontext_ = nullptr;
}
inline const ::testsgen::SettingsContext& SnippetRequest::_internal_settingscontext() const {
  const ::testsgen::SettingsContext* p = _impl_.settingscontext_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::SettingsContext&>(
      ::testsgen::_SettingsContext_default_instance_);
}
inline const ::testsgen::SettingsContext& SnippetRequest::settingscontext() const {
  // @@protoc_insertion_point(field_get:testsgen.SnippetRequest.settingsContext)
  return _internal_settingscontext();
}
inline void SnippetRequest::unsafe_arena_set_allocated_settingscontext(
    ::testsgen::SettingsContext* settingscontext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settingscontext_);
  }
  _impl_.settingscontext_ = settingscontext;
  if (settingscontext) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.SnippetRequest.settingsContext)
}
inline ::testsgen::SettingsContext* SnippetRequest::release_settingscontext() {
  
  ::testsgen::SettingsContext* temp = _impl_.settingscontext_;
  _impl_.settingscontext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::SettingsContext* SnippetRequest::unsafe_arena_release_settingscontext() {
  // @@protoc_insertion_point(field_release:testsgen.SnippetRequest.settingsContext)
  
  ::testsgen::SettingsContext* temp = _impl_.settingscontext_;
  _impl_.settingscontext_ = nullptr;
  return temp;
}
inline ::testsgen::SettingsContext* SnippetRequest::_internal_mutable_settingscontext() {
  
  if (_impl_.settingscontext_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::SettingsContext>(GetArenaForAllocation());
    _impl_.settingscontext_ = p;
  }
  return _impl_.settingscontext_;
}
inline ::testsgen::SettingsContext* SnippetRequest::mutable_settingscontext() {
  ::testsgen::SettingsContext* _msg = _internal_mutable_settingscontext();
  // @@protoc_insertion_point(field_mutable:testsgen.SnippetRequest.settingsContext)
  return _msg;
}
inline void SnippetRequest::set_allocated_settingscontext(::testsgen::SettingsContext* settingscontext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.settingscontext_;
  }
  if (settingscontext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settingscontext);
    if (message_arena != submessage_arena) {
      settingscontext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settingscontext, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.settingscontext_ = settingscontext;
  // @@protoc_insertion_point(field_set_allocated:testsgen.SnippetRequest.settingsContext)
}

// string filePath = 3;
inline void SnippetRequest::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& SnippetRequest::filepath() const {
  // @@protoc_insertion_point(field_get:testsgen.SnippetRequest.filePath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SnippetRequest::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.SnippetRequest.filePath)
}
inline std::string* SnippetRequest::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:testsgen.SnippetRequest.filePath)
  return _s;
}
inline const std::string& SnippetRequest::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void SnippetRequest::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* SnippetRequest::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* SnippetRequest::release_filepath() {
  // @@protoc_insertion_point(field_release:testsgen.SnippetRequest.filePath)
  return _impl_.filepath_.Release();
}
inline void SnippetRequest::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.SnippetRequest.filePath)
}

// -------------------------------------------------------------------

// ProjectRequest

// .testsgen.ProjectContext projectContext = 1;
inline bool ProjectRequest::_internal_has_projectcontext() const {
  return this != internal_default_instance() && _impl_.projectcontext_ != nullptr;
}
inline bool ProjectRequest::has_projectcontext() const {
  return _internal_has_projectcontext();
}
inline void ProjectRequest::clear_projectcontext() {
  if (GetArenaForAllocation() == nullptr && _impl_.projectcontext_ != nullptr) {
    delete _impl_.projectcontext_;
  }
  _impl_.projectcontext_ = nullptr;
}
inline const ::testsgen::ProjectContext& ProjectRequest::_internal_projectcontext() const {
  const ::testsgen::ProjectContext* p = _impl_.projectcontext_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::ProjectContext&>(
      ::testsgen::_ProjectContext_default_instance_);
}
inline const ::testsgen::ProjectContext& ProjectRequest::projectcontext() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectRequest.projectContext)
  return _internal_projectcontext();
}
inline void ProjectRequest::unsafe_arena_set_allocated_projectcontext(
    ::testsgen::ProjectContext* projectcontext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectcontext_);
  }
  _impl_.projectcontext_ = projectcontext;
  if (projectcontext) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.ProjectRequest.projectContext)
}
inline ::testsgen::ProjectContext* ProjectRequest::release_projectcontext() {
  
  ::testsgen::ProjectContext* temp = _impl_.projectcontext_;
  _impl_.projectcontext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::ProjectContext* ProjectRequest::unsafe_arena_release_projectcontext() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectRequest.projectContext)
  
  ::testsgen::ProjectContext* temp = _impl_.projectcontext_;
  _impl_.projectcontext_ = nullptr;
  return temp;
}
inline ::testsgen::ProjectContext* ProjectRequest::_internal_mutable_projectcontext() {
  
  if (_impl_.projectcontext_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::ProjectContext>(GetArenaForAllocation());
    _impl_.projectcontext_ = p;
  }
  return _impl_.projectcontext_;
}
inline ::testsgen::ProjectContext* ProjectRequest::mutable_projectcontext() {
  ::testsgen::ProjectContext* _msg = _internal_mutable_projectcontext();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectRequest.projectContext)
  return _msg;
}
inline void ProjectRequest::set_allocated_projectcontext(::testsgen::ProjectContext* projectcontext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.projectcontext_;
  }
  if (projectcontext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(projectcontext);
    if (message_arena != submessage_arena) {
      projectcontext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projectcontext, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.projectcontext_ = projectcontext;
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectRequest.projectContext)
}

// .testsgen.SettingsContext settingsContext = 2;
inline bool ProjectRequest::_internal_has_settingscontext() const {
  return this != internal_default_instance() && _impl_.settingscontext_ != nullptr;
}
inline bool ProjectRequest::has_settingscontext() const {
  return _internal_has_settingscontext();
}
inline void ProjectRequest::clear_settingscontext() {
  if (GetArenaForAllocation() == nullptr && _impl_.settingscontext_ != nullptr) {
    delete _impl_.settingscontext_;
  }
  _impl_.settingscontext_ = nullptr;
}
inline const ::testsgen::SettingsContext& ProjectRequest::_internal_settingscontext() const {
  const ::testsgen::SettingsContext* p = _impl_.settingscontext_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::SettingsContext&>(
      ::testsgen::_SettingsContext_default_instance_);
}
inline const ::testsgen::SettingsContext& ProjectRequest::settingscontext() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectRequest.settingsContext)
  return _internal_settingscontext();
}
inline void ProjectRequest::unsafe_arena_set_allocated_settingscontext(
    ::testsgen::SettingsContext* settingscontext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settingscontext_);
  }
  _impl_.settingscontext_ = settingscontext;
  if (settingscontext) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.ProjectRequest.settingsContext)
}
inline ::testsgen::SettingsContext* ProjectRequest::release_settingscontext() {
  
  ::testsgen::SettingsContext* temp = _impl_.settingscontext_;
  _impl_.settingscontext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::SettingsContext* ProjectRequest::unsafe_arena_release_settingscontext() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectRequest.settingsContext)
  
  ::testsgen::SettingsContext* temp = _impl_.settingscontext_;
  _impl_.settingscontext_ = nullptr;
  return temp;
}
inline ::testsgen::SettingsContext* ProjectRequest::_internal_mutable_settingscontext() {
  
  if (_impl_.settingscontext_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::SettingsContext>(GetArenaForAllocation());
    _impl_.settingscontext_ = p;
  }
  return _impl_.settingscontext_;
}
inline ::testsgen::SettingsContext* ProjectRequest::mutable_settingscontext() {
  ::testsgen::SettingsContext* _msg = _internal_mutable_settingscontext();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectRequest.settingsContext)
  return _msg;
}
inline void ProjectRequest::set_allocated_settingscontext(::testsgen::SettingsContext* settingscontext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.settingscontext_;
  }
  if (settingscontext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settingscontext);
    if (message_arena != submessage_arena) {
      settingscontext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settingscontext, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.settingscontext_ = settingscontext;
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectRequest.settingsContext)
}

// repeated string sourcePaths = 3;
inline int ProjectRequest::_internal_sourcepaths_size() const {
  return _impl_.sourcepaths_.size();
}
inline int ProjectRequest::sourcepaths_size() const {
  return _internal_sourcepaths_size();
}
inline void ProjectRequest::clear_sourcepaths() {
  _impl_.sourcepaths_.Clear();
}
inline std::string* ProjectRequest::add_sourcepaths() {
  std::string* _s = _internal_add_sourcepaths();
  // @@protoc_insertion_point(field_add_mutable:testsgen.ProjectRequest.sourcePaths)
  return _s;
}
inline const std::string& ProjectRequest::_internal_sourcepaths(int index) const {
  return _impl_.sourcepaths_.Get(index);
}
inline const std::string& ProjectRequest::sourcepaths(int index) const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectRequest.sourcePaths)
  return _internal_sourcepaths(index);
}
inline std::string* ProjectRequest::mutable_sourcepaths(int index) {
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectRequest.sourcePaths)
  return _impl_.sourcepaths_.Mutable(index);
}
inline void ProjectRequest::set_sourcepaths(int index, const std::string& value) {
  _impl_.sourcepaths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:testsgen.ProjectRequest.sourcePaths)
}
inline void ProjectRequest::set_sourcepaths(int index, std::string&& value) {
  _impl_.sourcepaths_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:testsgen.ProjectRequest.sourcePaths)
}
inline void ProjectRequest::set_sourcepaths(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sourcepaths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:testsgen.ProjectRequest.sourcePaths)
}
inline void ProjectRequest::set_sourcepaths(int index, const char* value, size_t size) {
  _impl_.sourcepaths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:testsgen.ProjectRequest.sourcePaths)
}
inline std::string* ProjectRequest::_internal_add_sourcepaths() {
  return _impl_.sourcepaths_.Add();
}
inline void ProjectRequest::add_sourcepaths(const std::string& value) {
  _impl_.sourcepaths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:testsgen.ProjectRequest.sourcePaths)
}
inline void ProjectRequest::add_sourcepaths(std::string&& value) {
  _impl_.sourcepaths_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:testsgen.ProjectRequest.sourcePaths)
}
inline void ProjectRequest::add_sourcepaths(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sourcepaths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:testsgen.ProjectRequest.sourcePaths)
}
inline void ProjectRequest::add_sourcepaths(const char* value, size_t size) {
  _impl_.sourcepaths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:testsgen.ProjectRequest.sourcePaths)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProjectRequest::sourcepaths() const {
  // @@protoc_insertion_point(field_list:testsgen.ProjectRequest.sourcePaths)
  return _impl_.sourcepaths_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProjectRequest::mutable_sourcepaths() {
  // @@protoc_insertion_point(field_mutable_list:testsgen.ProjectRequest.sourcePaths)
  return &_impl_.sourcepaths_;
}

// bool synchronizeCode = 4;
inline void ProjectRequest::clear_synchronizecode() {
  _impl_.synchronizecode_ = false;
}
inline bool ProjectRequest::_internal_synchronizecode() const {
  return _impl_.synchronizecode_;
}
inline bool ProjectRequest::synchronizecode() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectRequest.synchronizeCode)
  return _internal_synchronizecode();
}
inline void ProjectRequest::_internal_set_synchronizecode(bool value) {
  
  _impl_.synchronizecode_ = value;
}
inline void ProjectRequest::set_synchronizecode(bool value) {
  _internal_set_synchronizecode(value);
  // @@protoc_insertion_point(field_set:testsgen.ProjectRequest.synchronizeCode)
}

// string targetPath = 5;
inline void ProjectRequest::clear_targetpath() {
  _impl_.targetpath_.ClearToEmpty();
}
inline const std::string& ProjectRequest::targetpath() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectRequest.targetPath)
  return _internal_targetpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectRequest::set_targetpath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.targetpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.ProjectRequest.targetPath)
}
inline std::string* ProjectRequest::mutable_targetpath() {
  std::string* _s = _internal_mutable_targetpath();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectRequest.targetPath)
  return _s;
}
inline const std::string& ProjectRequest::_internal_targetpath() const {
  return _impl_.targetpath_.Get();
}
inline void ProjectRequest::_internal_set_targetpath(const std::string& value) {
  
  _impl_.targetpath_.Set(value, GetArenaForAllocation());
}
inline std::string* ProjectRequest::_internal_mutable_targetpath() {
  
  return _impl_.targetpath_.Mutable(GetArenaForAllocation());
}
inline std::string* ProjectRequest::release_targetpath() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectRequest.targetPath)
  return _impl_.targetpath_.Release();
}
inline void ProjectRequest::set_allocated_targetpath(std::string* targetpath) {
  if (targetpath != nullptr) {
    
  } else {
    
  }
  _impl_.targetpath_.SetAllocated(targetpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.targetpath_.IsDefault()) {
    _impl_.targetpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectRequest.targetPath)
}

// -------------------------------------------------------------------

// FileRequest

// .testsgen.ProjectRequest projectRequest = 1;
inline bool FileRequest::_internal_has_projectrequest() const {
  return this != internal_default_instance() && _impl_.projectrequest_ != nullptr;
}
inline bool FileRequest::has_projectrequest() const {
  return _internal_has_projectrequest();
}
inline void FileRequest::clear_projectrequest() {
  if (GetArenaForAllocation() == nullptr && _impl_.projectrequest_ != nullptr) {
    delete _impl_.projectrequest_;
  }
  _impl_.projectrequest_ = nullptr;
}
inline const ::testsgen::ProjectRequest& FileRequest::_internal_projectrequest() const {
  const ::testsgen::ProjectRequest* p = _impl_.projectrequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::ProjectRequest&>(
      ::testsgen::_ProjectRequest_default_instance_);
}
inline const ::testsgen::ProjectRequest& FileRequest::projectrequest() const {
  // @@protoc_insertion_point(field_get:testsgen.FileRequest.projectRequest)
  return _internal_projectrequest();
}
inline void FileRequest::unsafe_arena_set_allocated_projectrequest(
    ::testsgen::ProjectRequest* projectrequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectrequest_);
  }
  _impl_.projectrequest_ = projectrequest;
  if (projectrequest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.FileRequest.projectRequest)
}
inline ::testsgen::ProjectRequest* FileRequest::release_projectrequest() {
  
  ::testsgen::ProjectRequest* temp = _impl_.projectrequest_;
  _impl_.projectrequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::ProjectRequest* FileRequest::unsafe_arena_release_projectrequest() {
  // @@protoc_insertion_point(field_release:testsgen.FileRequest.projectRequest)
  
  ::testsgen::ProjectRequest* temp = _impl_.projectrequest_;
  _impl_.projectrequest_ = nullptr;
  return temp;
}
inline ::testsgen::ProjectRequest* FileRequest::_internal_mutable_projectrequest() {
  
  if (_impl_.projectrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::ProjectRequest>(GetArenaForAllocation());
    _impl_.projectrequest_ = p;
  }
  return _impl_.projectrequest_;
}
inline ::testsgen::ProjectRequest* FileRequest::mutable_projectrequest() {
  ::testsgen::ProjectRequest* _msg = _internal_mutable_projectrequest();
  // @@protoc_insertion_point(field_mutable:testsgen.FileRequest.projectRequest)
  return _msg;
}
inline void FileRequest::set_allocated_projectrequest(::testsgen::ProjectRequest* projectrequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.projectrequest_;
  }
  if (projectrequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(projectrequest);
    if (message_arena != submessage_arena) {
      projectrequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projectrequest, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.projectrequest_ = projectrequest;
  // @@protoc_insertion_point(field_set_allocated:testsgen.FileRequest.projectRequest)
}

// string filePath = 2;
inline void FileRequest::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& FileRequest::filepath() const {
  // @@protoc_insertion_point(field_get:testsgen.FileRequest.filePath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileRequest::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.FileRequest.filePath)
}
inline std::string* FileRequest::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:testsgen.FileRequest.filePath)
  return _s;
}
inline const std::string& FileRequest::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void FileRequest::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* FileRequest::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* FileRequest::release_filepath() {
  // @@protoc_insertion_point(field_release:testsgen.FileRequest.filePath)
  return _impl_.filepath_.Release();
}
inline void FileRequest::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.FileRequest.filePath)
}

// -------------------------------------------------------------------

// FolderRequest

// .testsgen.ProjectRequest projectRequest = 1;
inline bool FolderRequest::_internal_has_projectrequest() const {
  return this != internal_default_instance() && _impl_.projectrequest_ != nullptr;
}
inline bool FolderRequest::has_projectrequest() const {
  return _internal_has_projectrequest();
}
inline void FolderRequest::clear_projectrequest() {
  if (GetArenaForAllocation() == nullptr && _impl_.projectrequest_ != nullptr) {
    delete _impl_.projectrequest_;
  }
  _impl_.projectrequest_ = nullptr;
}
inline const ::testsgen::ProjectRequest& FolderRequest::_internal_projectrequest() const {
  const ::testsgen::ProjectRequest* p = _impl_.projectrequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::ProjectRequest&>(
      ::testsgen::_ProjectRequest_default_instance_);
}
inline const ::testsgen::ProjectRequest& FolderRequest::projectrequest() const {
  // @@protoc_insertion_point(field_get:testsgen.FolderRequest.projectRequest)
  return _internal_projectrequest();
}
inline void FolderRequest::unsafe_arena_set_allocated_projectrequest(
    ::testsgen::ProjectRequest* projectrequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectrequest_);
  }
  _impl_.projectrequest_ = projectrequest;
  if (projectrequest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.FolderRequest.projectRequest)
}
inline ::testsgen::ProjectRequest* FolderRequest::release_projectrequest() {
  
  ::testsgen::ProjectRequest* temp = _impl_.projectrequest_;
  _impl_.projectrequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::ProjectRequest* FolderRequest::unsafe_arena_release_projectrequest() {
  // @@protoc_insertion_point(field_release:testsgen.FolderRequest.projectRequest)
  
  ::testsgen::ProjectRequest* temp = _impl_.projectrequest_;
  _impl_.projectrequest_ = nullptr;
  return temp;
}
inline ::testsgen::ProjectRequest* FolderRequest::_internal_mutable_projectrequest() {
  
  if (_impl_.projectrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::ProjectRequest>(GetArenaForAllocation());
    _impl_.projectrequest_ = p;
  }
  return _impl_.projectrequest_;
}
inline ::testsgen::ProjectRequest* FolderRequest::mutable_projectrequest() {
  ::testsgen::ProjectRequest* _msg = _internal_mutable_projectrequest();
  // @@protoc_insertion_point(field_mutable:testsgen.FolderRequest.projectRequest)
  return _msg;
}
inline void FolderRequest::set_allocated_projectrequest(::testsgen::ProjectRequest* projectrequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.projectrequest_;
  }
  if (projectrequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(projectrequest);
    if (message_arena != submessage_arena) {
      projectrequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projectrequest, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.projectrequest_ = projectrequest;
  // @@protoc_insertion_point(field_set_allocated:testsgen.FolderRequest.projectRequest)
}

// string folderPath = 2;
inline void FolderRequest::clear_folderpath() {
  _impl_.folderpath_.ClearToEmpty();
}
inline const std::string& FolderRequest::folderpath() const {
  // @@protoc_insertion_point(field_get:testsgen.FolderRequest.folderPath)
  return _internal_folderpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FolderRequest::set_folderpath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.folderpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.FolderRequest.folderPath)
}
inline std::string* FolderRequest::mutable_folderpath() {
  std::string* _s = _internal_mutable_folderpath();
  // @@protoc_insertion_point(field_mutable:testsgen.FolderRequest.folderPath)
  return _s;
}
inline const std::string& FolderRequest::_internal_folderpath() const {
  return _impl_.folderpath_.Get();
}
inline void FolderRequest::_internal_set_folderpath(const std::string& value) {
  
  _impl_.folderpath_.Set(value, GetArenaForAllocation());
}
inline std::string* FolderRequest::_internal_mutable_folderpath() {
  
  return _impl_.folderpath_.Mutable(GetArenaForAllocation());
}
inline std::string* FolderRequest::release_folderpath() {
  // @@protoc_insertion_point(field_release:testsgen.FolderRequest.folderPath)
  return _impl_.folderpath_.Release();
}
inline void FolderRequest::set_allocated_folderpath(std::string* folderpath) {
  if (folderpath != nullptr) {
    
  } else {
    
  }
  _impl_.folderpath_.SetAllocated(folderpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.folderpath_.IsDefault()) {
    _impl_.folderpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.FolderRequest.folderPath)
}

// -------------------------------------------------------------------

// LineRequest

// .testsgen.ProjectRequest projectRequest = 1;
inline bool LineRequest::_internal_has_projectrequest() const {
  return this != internal_default_instance() && _impl_.projectrequest_ != nullptr;
}
inline bool LineRequest::has_projectrequest() const {
  return _internal_has_projectrequest();
}
inline void LineRequest::clear_projectrequest() {
  if (GetArenaForAllocation() == nullptr && _impl_.projectrequest_ != nullptr) {
    delete _impl_.projectrequest_;
  }
  _impl_.projectrequest_ = nullptr;
}
inline const ::testsgen::ProjectRequest& LineRequest::_internal_projectrequest() const {
  const ::testsgen::ProjectRequest* p = _impl_.projectrequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::ProjectRequest&>(
      ::testsgen::_ProjectRequest_default_instance_);
}
inline const ::testsgen::ProjectRequest& LineRequest::projectrequest() const {
  // @@protoc_insertion_point(field_get:testsgen.LineRequest.projectRequest)
  return _internal_projectrequest();
}
inline void LineRequest::unsafe_arena_set_allocated_projectrequest(
    ::testsgen::ProjectRequest* projectrequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectrequest_);
  }
  _impl_.projectrequest_ = projectrequest;
  if (projectrequest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.LineRequest.projectRequest)
}
inline ::testsgen::ProjectRequest* LineRequest::release_projectrequest() {
  
  ::testsgen::ProjectRequest* temp = _impl_.projectrequest_;
  _impl_.projectrequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::ProjectRequest* LineRequest::unsafe_arena_release_projectrequest() {
  // @@protoc_insertion_point(field_release:testsgen.LineRequest.projectRequest)
  
  ::testsgen::ProjectRequest* temp = _impl_.projectrequest_;
  _impl_.projectrequest_ = nullptr;
  return temp;
}
inline ::testsgen::ProjectRequest* LineRequest::_internal_mutable_projectrequest() {
  
  if (_impl_.projectrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::ProjectRequest>(GetArenaForAllocation());
    _impl_.projectrequest_ = p;
  }
  return _impl_.projectrequest_;
}
inline ::testsgen::ProjectRequest* LineRequest::mutable_projectrequest() {
  ::testsgen::ProjectRequest* _msg = _internal_mutable_projectrequest();
  // @@protoc_insertion_point(field_mutable:testsgen.LineRequest.projectRequest)
  return _msg;
}
inline void LineRequest::set_allocated_projectrequest(::testsgen::ProjectRequest* projectrequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.projectrequest_;
  }
  if (projectrequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(projectrequest);
    if (message_arena != submessage_arena) {
      projectrequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projectrequest, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.projectrequest_ = projectrequest;
  // @@protoc_insertion_point(field_set_allocated:testsgen.LineRequest.projectRequest)
}

// .testsgen.SourceInfo sourceInfo = 2;
inline bool LineRequest::_internal_has_sourceinfo() const {
  return this != internal_default_instance() && _impl_.sourceinfo_ != nullptr;
}
inline bool LineRequest::has_sourceinfo() const {
  return _internal_has_sourceinfo();
}
inline const ::testsgen::SourceInfo& LineRequest::_internal_sourceinfo() const {
  const ::testsgen::SourceInfo* p = _impl_.sourceinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::SourceInfo&>(
      ::testsgen::_SourceInfo_default_instance_);
}
inline const ::testsgen::SourceInfo& LineRequest::sourceinfo() const {
  // @@protoc_insertion_point(field_get:testsgen.LineRequest.sourceInfo)
  return _internal_sourceinfo();
}
inline void LineRequest::unsafe_arena_set_allocated_sourceinfo(
    ::testsgen::SourceInfo* sourceinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sourceinfo_);
  }
  _impl_.sourceinfo_ = sourceinfo;
  if (sourceinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.LineRequest.sourceInfo)
}
inline ::testsgen::SourceInfo* LineRequest::release_sourceinfo() {
  
  ::testsgen::SourceInfo* temp = _impl_.sourceinfo_;
  _impl_.sourceinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::SourceInfo* LineRequest::unsafe_arena_release_sourceinfo() {
  // @@protoc_insertion_point(field_release:testsgen.LineRequest.sourceInfo)
  
  ::testsgen::SourceInfo* temp = _impl_.sourceinfo_;
  _impl_.sourceinfo_ = nullptr;
  return temp;
}
inline ::testsgen::SourceInfo* LineRequest::_internal_mutable_sourceinfo() {
  
  if (_impl_.sourceinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::SourceInfo>(GetArenaForAllocation());
    _impl_.sourceinfo_ = p;
  }
  return _impl_.sourceinfo_;
}
inline ::testsgen::SourceInfo* LineRequest::mutable_sourceinfo() {
  ::testsgen::SourceInfo* _msg = _internal_mutable_sourceinfo();
  // @@protoc_insertion_point(field_mutable:testsgen.LineRequest.sourceInfo)
  return _msg;
}
inline void LineRequest::set_allocated_sourceinfo(::testsgen::SourceInfo* sourceinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sourceinfo_);
  }
  if (sourceinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sourceinfo));
    if (message_arena != submessage_arena) {
      sourceinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sourceinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sourceinfo_ = sourceinfo;
  // @@protoc_insertion_point(field_set_allocated:testsgen.LineRequest.sourceInfo)
}

// -------------------------------------------------------------------

// FunctionRequest

// .testsgen.LineRequest lineRequest = 1;
inline bool FunctionRequest::_internal_has_linerequest() const {
  return this != internal_default_instance() && _impl_.linerequest_ != nullptr;
}
inline bool FunctionRequest::has_linerequest() const {
  return _internal_has_linerequest();
}
inline void FunctionRequest::clear_linerequest() {
  if (GetArenaForAllocation() == nullptr && _impl_.linerequest_ != nullptr) {
    delete _impl_.linerequest_;
  }
  _impl_.linerequest_ = nullptr;
}
inline const ::testsgen::LineRequest& FunctionRequest::_internal_linerequest() const {
  const ::testsgen::LineRequest* p = _impl_.linerequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::LineRequest&>(
      ::testsgen::_LineRequest_default_instance_);
}
inline const ::testsgen::LineRequest& FunctionRequest::linerequest() const {
  // @@protoc_insertion_point(field_get:testsgen.FunctionRequest.lineRequest)
  return _internal_linerequest();
}
inline void FunctionRequest::unsafe_arena_set_allocated_linerequest(
    ::testsgen::LineRequest* linerequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linerequest_);
  }
  _impl_.linerequest_ = linerequest;
  if (linerequest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.FunctionRequest.lineRequest)
}
inline ::testsgen::LineRequest* FunctionRequest::release_linerequest() {
  
  ::testsgen::LineRequest* temp = _impl_.linerequest_;
  _impl_.linerequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::LineRequest* FunctionRequest::unsafe_arena_release_linerequest() {
  // @@protoc_insertion_point(field_release:testsgen.FunctionRequest.lineRequest)
  
  ::testsgen::LineRequest* temp = _impl_.linerequest_;
  _impl_.linerequest_ = nullptr;
  return temp;
}
inline ::testsgen::LineRequest* FunctionRequest::_internal_mutable_linerequest() {
  
  if (_impl_.linerequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::LineRequest>(GetArenaForAllocation());
    _impl_.linerequest_ = p;
  }
  return _impl_.linerequest_;
}
inline ::testsgen::LineRequest* FunctionRequest::mutable_linerequest() {
  ::testsgen::LineRequest* _msg = _internal_mutable_linerequest();
  // @@protoc_insertion_point(field_mutable:testsgen.FunctionRequest.lineRequest)
  return _msg;
}
inline void FunctionRequest::set_allocated_linerequest(::testsgen::LineRequest* linerequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linerequest_;
  }
  if (linerequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linerequest);
    if (message_arena != submessage_arena) {
      linerequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linerequest, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linerequest_ = linerequest;
  // @@protoc_insertion_point(field_set_allocated:testsgen.FunctionRequest.lineRequest)
}

// -------------------------------------------------------------------

// ClassRequest

// .testsgen.LineRequest lineRequest = 1;
inline bool ClassRequest::_internal_has_linerequest() const {
  return this != internal_default_instance() && _impl_.linerequest_ != nullptr;
}
inline bool ClassRequest::has_linerequest() const {
  return _internal_has_linerequest();
}
inline void ClassRequest::clear_linerequest() {
  if (GetArenaForAllocation() == nullptr && _impl_.linerequest_ != nullptr) {
    delete _impl_.linerequest_;
  }
  _impl_.linerequest_ = nullptr;
}
inline const ::testsgen::LineRequest& ClassRequest::_internal_linerequest() const {
  const ::testsgen::LineRequest* p = _impl_.linerequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::LineRequest&>(
      ::testsgen::_LineRequest_default_instance_);
}
inline const ::testsgen::LineRequest& ClassRequest::linerequest() const {
  // @@protoc_insertion_point(field_get:testsgen.ClassRequest.lineRequest)
  return _internal_linerequest();
}
inline void ClassRequest::unsafe_arena_set_allocated_linerequest(
    ::testsgen::LineRequest* linerequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linerequest_);
  }
  _impl_.linerequest_ = linerequest;
  if (linerequest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.ClassRequest.lineRequest)
}
inline ::testsgen::LineRequest* ClassRequest::release_linerequest() {
  
  ::testsgen::LineRequest* temp = _impl_.linerequest_;
  _impl_.linerequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::LineRequest* ClassRequest::unsafe_arena_release_linerequest() {
  // @@protoc_insertion_point(field_release:testsgen.ClassRequest.lineRequest)
  
  ::testsgen::LineRequest* temp = _impl_.linerequest_;
  _impl_.linerequest_ = nullptr;
  return temp;
}
inline ::testsgen::LineRequest* ClassRequest::_internal_mutable_linerequest() {
  
  if (_impl_.linerequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::LineRequest>(GetArenaForAllocation());
    _impl_.linerequest_ = p;
  }
  return _impl_.linerequest_;
}
inline ::testsgen::LineRequest* ClassRequest::mutable_linerequest() {
  ::testsgen::LineRequest* _msg = _internal_mutable_linerequest();
  // @@protoc_insertion_point(field_mutable:testsgen.ClassRequest.lineRequest)
  return _msg;
}
inline void ClassRequest::set_allocated_linerequest(::testsgen::LineRequest* linerequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linerequest_;
  }
  if (linerequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linerequest);
    if (message_arena != submessage_arena) {
      linerequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linerequest, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linerequest_ = linerequest;
  // @@protoc_insertion_point(field_set_allocated:testsgen.ClassRequest.lineRequest)
}

// -------------------------------------------------------------------

// AssertionRequest

// .testsgen.LineRequest lineRequest = 1;
inline bool AssertionRequest::_internal_has_linerequest() const {
  return this != internal_default_instance() && _impl_.linerequest_ != nullptr;
}
inline bool AssertionRequest::has_linerequest() const {
  return _internal_has_linerequest();
}
inline void AssertionRequest::clear_linerequest() {
  if (GetArenaForAllocation() == nullptr && _impl_.linerequest_ != nullptr) {
    delete _impl_.linerequest_;
  }
  _impl_.linerequest_ = nullptr;
}
inline const ::testsgen::LineRequest& AssertionRequest::_internal_linerequest() const {
  const ::testsgen::LineRequest* p = _impl_.linerequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::LineRequest&>(
      ::testsgen::_LineRequest_default_instance_);
}
inline const ::testsgen::LineRequest& AssertionRequest::linerequest() const {
  // @@protoc_insertion_point(field_get:testsgen.AssertionRequest.lineRequest)
  return _internal_linerequest();
}
inline void AssertionRequest::unsafe_arena_set_allocated_linerequest(
    ::testsgen::LineRequest* linerequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linerequest_);
  }
  _impl_.linerequest_ = linerequest;
  if (linerequest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.AssertionRequest.lineRequest)
}
inline ::testsgen::LineRequest* AssertionRequest::release_linerequest() {
  
  ::testsgen::LineRequest* temp = _impl_.linerequest_;
  _impl_.linerequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::LineRequest* AssertionRequest::unsafe_arena_release_linerequest() {
  // @@protoc_insertion_point(field_release:testsgen.AssertionRequest.lineRequest)
  
  ::testsgen::LineRequest* temp = _impl_.linerequest_;
  _impl_.linerequest_ = nullptr;
  return temp;
}
inline ::testsgen::LineRequest* AssertionRequest::_internal_mutable_linerequest() {
  
  if (_impl_.linerequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::LineRequest>(GetArenaForAllocation());
    _impl_.linerequest_ = p;
  }
  return _impl_.linerequest_;
}
inline ::testsgen::LineRequest* AssertionRequest::mutable_linerequest() {
  ::testsgen::LineRequest* _msg = _internal_mutable_linerequest();
  // @@protoc_insertion_point(field_mutable:testsgen.AssertionRequest.lineRequest)
  return _msg;
}
inline void AssertionRequest::set_allocated_linerequest(::testsgen::LineRequest* linerequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linerequest_;
  }
  if (linerequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linerequest);
    if (message_arena != submessage_arena) {
      linerequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linerequest, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linerequest_ = linerequest;
  // @@protoc_insertion_point(field_set_allocated:testsgen.AssertionRequest.lineRequest)
}

// -------------------------------------------------------------------

// PredicateRequest

// .testsgen.LineRequest lineRequest = 1;
inline bool PredicateRequest::_internal_has_linerequest() const {
  return this != internal_default_instance() && _impl_.linerequest_ != nullptr;
}
inline bool PredicateRequest::has_linerequest() const {
  return _internal_has_linerequest();
}
inline void PredicateRequest::clear_linerequest() {
  if (GetArenaForAllocation() == nullptr && _impl_.linerequest_ != nullptr) {
    delete _impl_.linerequest_;
  }
  _impl_.linerequest_ = nullptr;
}
inline const ::testsgen::LineRequest& PredicateRequest::_internal_linerequest() const {
  const ::testsgen::LineRequest* p = _impl_.linerequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::LineRequest&>(
      ::testsgen::_LineRequest_default_instance_);
}
inline const ::testsgen::LineRequest& PredicateRequest::linerequest() const {
  // @@protoc_insertion_point(field_get:testsgen.PredicateRequest.lineRequest)
  return _internal_linerequest();
}
inline void PredicateRequest::unsafe_arena_set_allocated_linerequest(
    ::testsgen::LineRequest* linerequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linerequest_);
  }
  _impl_.linerequest_ = linerequest;
  if (linerequest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.PredicateRequest.lineRequest)
}
inline ::testsgen::LineRequest* PredicateRequest::release_linerequest() {
  
  ::testsgen::LineRequest* temp = _impl_.linerequest_;
  _impl_.linerequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::LineRequest* PredicateRequest::unsafe_arena_release_linerequest() {
  // @@protoc_insertion_point(field_release:testsgen.PredicateRequest.lineRequest)
  
  ::testsgen::LineRequest* temp = _impl_.linerequest_;
  _impl_.linerequest_ = nullptr;
  return temp;
}
inline ::testsgen::LineRequest* PredicateRequest::_internal_mutable_linerequest() {
  
  if (_impl_.linerequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::LineRequest>(GetArenaForAllocation());
    _impl_.linerequest_ = p;
  }
  return _impl_.linerequest_;
}
inline ::testsgen::LineRequest* PredicateRequest::mutable_linerequest() {
  ::testsgen::LineRequest* _msg = _internal_mutable_linerequest();
  // @@protoc_insertion_point(field_mutable:testsgen.PredicateRequest.lineRequest)
  return _msg;
}
inline void PredicateRequest::set_allocated_linerequest(::testsgen::LineRequest* linerequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linerequest_;
  }
  if (linerequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linerequest);
    if (message_arena != submessage_arena) {
      linerequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linerequest, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linerequest_ = linerequest;
  // @@protoc_insertion_point(field_set_allocated:testsgen.PredicateRequest.lineRequest)
}

// .testsgen.PredicateInfo predicateInfo = 2;
inline bool PredicateRequest::_internal_has_predicateinfo() const {
  return this != internal_default_instance() && _impl_.predicateinfo_ != nullptr;
}
inline bool PredicateRequest::has_predicateinfo() const {
  return _internal_has_predicateinfo();
}
inline const ::testsgen::PredicateInfo& PredicateRequest::_internal_predicateinfo() const {
  const ::testsgen::PredicateInfo* p = _impl_.predicateinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::PredicateInfo&>(
      ::testsgen::_PredicateInfo_default_instance_);
}
inline const ::testsgen::PredicateInfo& PredicateRequest::predicateinfo() const {
  // @@protoc_insertion_point(field_get:testsgen.PredicateRequest.predicateInfo)
  return _internal_predicateinfo();
}
inline void PredicateRequest::unsafe_arena_set_allocated_predicateinfo(
    ::testsgen::PredicateInfo* predicateinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.predicateinfo_);
  }
  _impl_.predicateinfo_ = predicateinfo;
  if (predicateinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.PredicateRequest.predicateInfo)
}
inline ::testsgen::PredicateInfo* PredicateRequest::release_predicateinfo() {
  
  ::testsgen::PredicateInfo* temp = _impl_.predicateinfo_;
  _impl_.predicateinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::PredicateInfo* PredicateRequest::unsafe_arena_release_predicateinfo() {
  // @@protoc_insertion_point(field_release:testsgen.PredicateRequest.predicateInfo)
  
  ::testsgen::PredicateInfo* temp = _impl_.predicateinfo_;
  _impl_.predicateinfo_ = nullptr;
  return temp;
}
inline ::testsgen::PredicateInfo* PredicateRequest::_internal_mutable_predicateinfo() {
  
  if (_impl_.predicateinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::PredicateInfo>(GetArenaForAllocation());
    _impl_.predicateinfo_ = p;
  }
  return _impl_.predicateinfo_;
}
inline ::testsgen::PredicateInfo* PredicateRequest::mutable_predicateinfo() {
  ::testsgen::PredicateInfo* _msg = _internal_mutable_predicateinfo();
  // @@protoc_insertion_point(field_mutable:testsgen.PredicateRequest.predicateInfo)
  return _msg;
}
inline void PredicateRequest::set_allocated_predicateinfo(::testsgen::PredicateInfo* predicateinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.predicateinfo_);
  }
  if (predicateinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(predicateinfo));
    if (message_arena != submessage_arena) {
      predicateinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, predicateinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.predicateinfo_ = predicateinfo;
  // @@protoc_insertion_point(field_set_allocated:testsgen.PredicateRequest.predicateInfo)
}

// -------------------------------------------------------------------

// StubsResponse

// repeated .testsgen.SourceCode stubSources = 1;
inline int StubsResponse::_internal_stubsources_size() const {
  return _impl_.stubsources_.size();
}
inline int StubsResponse::stubsources_size() const {
  return _internal_stubsources_size();
}
inline ::testsgen::SourceCode* StubsResponse::mutable_stubsources(int index) {
  // @@protoc_insertion_point(field_mutable:testsgen.StubsResponse.stubSources)
  return _impl_.stubsources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceCode >*
StubsResponse::mutable_stubsources() {
  // @@protoc_insertion_point(field_mutable_list:testsgen.StubsResponse.stubSources)
  return &_impl_.stubsources_;
}
inline const ::testsgen::SourceCode& StubsResponse::_internal_stubsources(int index) const {
  return _impl_.stubsources_.Get(index);
}
inline const ::testsgen::SourceCode& StubsResponse::stubsources(int index) const {
  // @@protoc_insertion_point(field_get:testsgen.StubsResponse.stubSources)
  return _internal_stubsources(index);
}
inline ::testsgen::SourceCode* StubsResponse::_internal_add_stubsources() {
  return _impl_.stubsources_.Add();
}
inline ::testsgen::SourceCode* StubsResponse::add_stubsources() {
  ::testsgen::SourceCode* _add = _internal_add_stubsources();
  // @@protoc_insertion_point(field_add:testsgen.StubsResponse.stubSources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceCode >&
StubsResponse::stubsources() const {
  // @@protoc_insertion_point(field_list:testsgen.StubsResponse.stubSources)
  return _impl_.stubsources_;
}

// .testsgen.Progress progress = 2;
inline bool StubsResponse::_internal_has_progress() const {
  return this != internal_default_instance() && _impl_.progress_ != nullptr;
}
inline bool StubsResponse::has_progress() const {
  return _internal_has_progress();
}
inline const ::testsgen::Progress& StubsResponse::_internal_progress() const {
  const ::testsgen::Progress* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::Progress&>(
      ::testsgen::_Progress_default_instance_);
}
inline const ::testsgen::Progress& StubsResponse::progress() const {
  // @@protoc_insertion_point(field_get:testsgen.StubsResponse.progress)
  return _internal_progress();
}
inline void StubsResponse::unsafe_arena_set_allocated_progress(
    ::testsgen::Progress* progress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = progress;
  if (progress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.StubsResponse.progress)
}
inline ::testsgen::Progress* StubsResponse::release_progress() {
  
  ::testsgen::Progress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::Progress* StubsResponse::unsafe_arena_release_progress() {
  // @@protoc_insertion_point(field_release:testsgen.StubsResponse.progress)
  
  ::testsgen::Progress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::testsgen::Progress* StubsResponse::_internal_mutable_progress() {
  
  if (_impl_.progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::Progress>(GetArenaForAllocation());
    _impl_.progress_ = p;
  }
  return _impl_.progress_;
}
inline ::testsgen::Progress* StubsResponse::mutable_progress() {
  ::testsgen::Progress* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:testsgen.StubsResponse.progress)
  return _msg;
}
inline void StubsResponse::set_allocated_progress(::testsgen::Progress* progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  if (progress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(progress));
    if (message_arena != submessage_arena) {
      progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.progress_ = progress;
  // @@protoc_insertion_point(field_set_allocated:testsgen.StubsResponse.progress)
}

// -------------------------------------------------------------------

// TestsResponse

// repeated .testsgen.SourceCode testSources = 1;
inline int TestsResponse::_internal_testsources_size() const {
  return _impl_.testsources_.size();
}
inline int TestsResponse::testsources_size() const {
  return _internal_testsources_size();
}
inline ::testsgen::SourceCode* TestsResponse::mutable_testsources(int index) {
  // @@protoc_insertion_point(field_mutable:testsgen.TestsResponse.testSources)
  return _impl_.testsources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceCode >*
TestsResponse::mutable_testsources() {
  // @@protoc_insertion_point(field_mutable_list:testsgen.TestsResponse.testSources)
  return &_impl_.testsources_;
}
inline const ::testsgen::SourceCode& TestsResponse::_internal_testsources(int index) const {
  return _impl_.testsources_.Get(index);
}
inline const ::testsgen::SourceCode& TestsResponse::testsources(int index) const {
  // @@protoc_insertion_point(field_get:testsgen.TestsResponse.testSources)
  return _internal_testsources(index);
}
inline ::testsgen::SourceCode* TestsResponse::_internal_add_testsources() {
  return _impl_.testsources_.Add();
}
inline ::testsgen::SourceCode* TestsResponse::add_testsources() {
  ::testsgen::SourceCode* _add = _internal_add_testsources();
  // @@protoc_insertion_point(field_add:testsgen.TestsResponse.testSources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceCode >&
TestsResponse::testsources() const {
  // @@protoc_insertion_point(field_list:testsgen.TestsResponse.testSources)
  return _impl_.testsources_;
}

// .testsgen.StubsResponse stubs = 2;
inline bool TestsResponse::_internal_has_stubs() const {
  return this != internal_default_instance() && _impl_.stubs_ != nullptr;
}
inline bool TestsResponse::has_stubs() const {
  return _internal_has_stubs();
}
inline void TestsResponse::clear_stubs() {
  if (GetArenaForAllocation() == nullptr && _impl_.stubs_ != nullptr) {
    delete _impl_.stubs_;
  }
  _impl_.stubs_ = nullptr;
}
inline const ::testsgen::StubsResponse& TestsResponse::_internal_stubs() const {
  const ::testsgen::StubsResponse* p = _impl_.stubs_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::StubsResponse&>(
      ::testsgen::_StubsResponse_default_instance_);
}
inline const ::testsgen::StubsResponse& TestsResponse::stubs() const {
  // @@protoc_insertion_point(field_get:testsgen.TestsResponse.stubs)
  return _internal_stubs();
}
inline void TestsResponse::unsafe_arena_set_allocated_stubs(
    ::testsgen::StubsResponse* stubs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stubs_);
  }
  _impl_.stubs_ = stubs;
  if (stubs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.TestsResponse.stubs)
}
inline ::testsgen::StubsResponse* TestsResponse::release_stubs() {
  
  ::testsgen::StubsResponse* temp = _impl_.stubs_;
  _impl_.stubs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::StubsResponse* TestsResponse::unsafe_arena_release_stubs() {
  // @@protoc_insertion_point(field_release:testsgen.TestsResponse.stubs)
  
  ::testsgen::StubsResponse* temp = _impl_.stubs_;
  _impl_.stubs_ = nullptr;
  return temp;
}
inline ::testsgen::StubsResponse* TestsResponse::_internal_mutable_stubs() {
  
  if (_impl_.stubs_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::StubsResponse>(GetArenaForAllocation());
    _impl_.stubs_ = p;
  }
  return _impl_.stubs_;
}
inline ::testsgen::StubsResponse* TestsResponse::mutable_stubs() {
  ::testsgen::StubsResponse* _msg = _internal_mutable_stubs();
  // @@protoc_insertion_point(field_mutable:testsgen.TestsResponse.stubs)
  return _msg;
}
inline void TestsResponse::set_allocated_stubs(::testsgen::StubsResponse* stubs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stubs_;
  }
  if (stubs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stubs);
    if (message_arena != submessage_arena) {
      stubs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stubs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stubs_ = stubs;
  // @@protoc_insertion_point(field_set_allocated:testsgen.TestsResponse.stubs)
}

// .testsgen.Progress progress = 3;
inline bool TestsResponse::_internal_has_progress() const {
  return this != internal_default_instance() && _impl_.progress_ != nullptr;
}
inline bool TestsResponse::has_progress() const {
  return _internal_has_progress();
}
inline const ::testsgen::Progress& TestsResponse::_internal_progress() const {
  const ::testsgen::Progress* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::Progress&>(
      ::testsgen::_Progress_default_instance_);
}
inline const ::testsgen::Progress& TestsResponse::progress() const {
  // @@protoc_insertion_point(field_get:testsgen.TestsResponse.progress)
  return _internal_progress();
}
inline void TestsResponse::unsafe_arena_set_allocated_progress(
    ::testsgen::Progress* progress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = progress;
  if (progress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.TestsResponse.progress)
}
inline ::testsgen::Progress* TestsResponse::release_progress() {
  
  ::testsgen::Progress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::Progress* TestsResponse::unsafe_arena_release_progress() {
  // @@protoc_insertion_point(field_release:testsgen.TestsResponse.progress)
  
  ::testsgen::Progress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::testsgen::Progress* TestsResponse::_internal_mutable_progress() {
  
  if (_impl_.progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::Progress>(GetArenaForAllocation());
    _impl_.progress_ = p;
  }
  return _impl_.progress_;
}
inline ::testsgen::Progress* TestsResponse::mutable_progress() {
  ::testsgen::Progress* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:testsgen.TestsResponse.progress)
  return _msg;
}
inline void TestsResponse::set_allocated_progress(::testsgen::Progress* progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  if (progress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(progress));
    if (message_arena != submessage_arena) {
      progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.progress_ = progress;
  // @@protoc_insertion_point(field_set_allocated:testsgen.TestsResponse.progress)
}

// -------------------------------------------------------------------

// SourceLine

// uint32 line = 1;
inline void SourceLine::clear_line() {
  _impl_.line_ = 0u;
}
inline uint32_t SourceLine::_internal_line() const {
  return _impl_.line_;
}
inline uint32_t SourceLine::line() const {
  // @@protoc_insertion_point(field_get:testsgen.SourceLine.line)
  return _internal_line();
}
inline void SourceLine::_internal_set_line(uint32_t value) {
  
  _impl_.line_ = value;
}
inline void SourceLine::set_line(uint32_t value) {
  _internal_set_line(value);
  // @@protoc_insertion_point(field_set:testsgen.SourceLine.line)
}

// -------------------------------------------------------------------

// FileCoverageSimplified

// string filePath = 1;
inline void FileCoverageSimplified::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& FileCoverageSimplified::filepath() const {
  // @@protoc_insertion_point(field_get:testsgen.FileCoverageSimplified.filePath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileCoverageSimplified::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.FileCoverageSimplified.filePath)
}
inline std::string* FileCoverageSimplified::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:testsgen.FileCoverageSimplified.filePath)
  return _s;
}
inline const std::string& FileCoverageSimplified::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void FileCoverageSimplified::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* FileCoverageSimplified::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* FileCoverageSimplified::release_filepath() {
  // @@protoc_insertion_point(field_release:testsgen.FileCoverageSimplified.filePath)
  return _impl_.filepath_.Release();
}
inline void FileCoverageSimplified::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.FileCoverageSimplified.filePath)
}

// repeated .testsgen.SourceLine fullCoverageLines = 2;
inline int FileCoverageSimplified::_internal_fullcoveragelines_size() const {
  return _impl_.fullcoveragelines_.size();
}
inline int FileCoverageSimplified::fullcoveragelines_size() const {
  return _internal_fullcoveragelines_size();
}
inline void FileCoverageSimplified::clear_fullcoveragelines() {
  _impl_.fullcoveragelines_.Clear();
}
inline ::testsgen::SourceLine* FileCoverageSimplified::mutable_fullcoveragelines(int index) {
  // @@protoc_insertion_point(field_mutable:testsgen.FileCoverageSimplified.fullCoverageLines)
  return _impl_.fullcoveragelines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine >*
FileCoverageSimplified::mutable_fullcoveragelines() {
  // @@protoc_insertion_point(field_mutable_list:testsgen.FileCoverageSimplified.fullCoverageLines)
  return &_impl_.fullcoveragelines_;
}
inline const ::testsgen::SourceLine& FileCoverageSimplified::_internal_fullcoveragelines(int index) const {
  return _impl_.fullcoveragelines_.Get(index);
}
inline const ::testsgen::SourceLine& FileCoverageSimplified::fullcoveragelines(int index) const {
  // @@protoc_insertion_point(field_get:testsgen.FileCoverageSimplified.fullCoverageLines)
  return _internal_fullcoveragelines(index);
}
inline ::testsgen::SourceLine* FileCoverageSimplified::_internal_add_fullcoveragelines() {
  return _impl_.fullcoveragelines_.Add();
}
inline ::testsgen::SourceLine* FileCoverageSimplified::add_fullcoveragelines() {
  ::testsgen::SourceLine* _add = _internal_add_fullcoveragelines();
  // @@protoc_insertion_point(field_add:testsgen.FileCoverageSimplified.fullCoverageLines)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine >&
FileCoverageSimplified::fullcoveragelines() const {
  // @@protoc_insertion_point(field_list:testsgen.FileCoverageSimplified.fullCoverageLines)
  return _impl_.fullcoveragelines_;
}

// repeated .testsgen.SourceLine partialCoverageLines = 3;
inline int FileCoverageSimplified::_internal_partialcoveragelines_size() const {
  return _impl_.partialcoveragelines_.size();
}
inline int FileCoverageSimplified::partialcoveragelines_size() const {
  return _internal_partialcoveragelines_size();
}
inline void FileCoverageSimplified::clear_partialcoveragelines() {
  _impl_.partialcoveragelines_.Clear();
}
inline ::testsgen::SourceLine* FileCoverageSimplified::mutable_partialcoveragelines(int index) {
  // @@protoc_insertion_point(field_mutable:testsgen.FileCoverageSimplified.partialCoverageLines)
  return _impl_.partialcoveragelines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine >*
FileCoverageSimplified::mutable_partialcoveragelines() {
  // @@protoc_insertion_point(field_mutable_list:testsgen.FileCoverageSimplified.partialCoverageLines)
  return &_impl_.partialcoveragelines_;
}
inline const ::testsgen::SourceLine& FileCoverageSimplified::_internal_partialcoveragelines(int index) const {
  return _impl_.partialcoveragelines_.Get(index);
}
inline const ::testsgen::SourceLine& FileCoverageSimplified::partialcoveragelines(int index) const {
  // @@protoc_insertion_point(field_get:testsgen.FileCoverageSimplified.partialCoverageLines)
  return _internal_partialcoveragelines(index);
}
inline ::testsgen::SourceLine* FileCoverageSimplified::_internal_add_partialcoveragelines() {
  return _impl_.partialcoveragelines_.Add();
}
inline ::testsgen::SourceLine* FileCoverageSimplified::add_partialcoveragelines() {
  ::testsgen::SourceLine* _add = _internal_add_partialcoveragelines();
  // @@protoc_insertion_point(field_add:testsgen.FileCoverageSimplified.partialCoverageLines)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine >&
FileCoverageSimplified::partialcoveragelines() const {
  // @@protoc_insertion_point(field_list:testsgen.FileCoverageSimplified.partialCoverageLines)
  return _impl_.partialcoveragelines_;
}

// repeated .testsgen.SourceLine noCoverageLines = 4;
inline int FileCoverageSimplified::_internal_nocoveragelines_size() const {
  return _impl_.nocoveragelines_.size();
}
inline int FileCoverageSimplified::nocoveragelines_size() const {
  return _internal_nocoveragelines_size();
}
inline void FileCoverageSimplified::clear_nocoveragelines() {
  _impl_.nocoveragelines_.Clear();
}
inline ::testsgen::SourceLine* FileCoverageSimplified::mutable_nocoveragelines(int index) {
  // @@protoc_insertion_point(field_mutable:testsgen.FileCoverageSimplified.noCoverageLines)
  return _impl_.nocoveragelines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine >*
FileCoverageSimplified::mutable_nocoveragelines() {
  // @@protoc_insertion_point(field_mutable_list:testsgen.FileCoverageSimplified.noCoverageLines)
  return &_impl_.nocoveragelines_;
}
inline const ::testsgen::SourceLine& FileCoverageSimplified::_internal_nocoveragelines(int index) const {
  return _impl_.nocoveragelines_.Get(index);
}
inline const ::testsgen::SourceLine& FileCoverageSimplified::nocoveragelines(int index) const {
  // @@protoc_insertion_point(field_get:testsgen.FileCoverageSimplified.noCoverageLines)
  return _internal_nocoveragelines(index);
}
inline ::testsgen::SourceLine* FileCoverageSimplified::_internal_add_nocoveragelines() {
  return _impl_.nocoveragelines_.Add();
}
inline ::testsgen::SourceLine* FileCoverageSimplified::add_nocoveragelines() {
  ::testsgen::SourceLine* _add = _internal_add_nocoveragelines();
  // @@protoc_insertion_point(field_add:testsgen.FileCoverageSimplified.noCoverageLines)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::SourceLine >&
FileCoverageSimplified::nocoveragelines() const {
  // @@protoc_insertion_point(field_list:testsgen.FileCoverageSimplified.noCoverageLines)
  return _impl_.nocoveragelines_;
}

// -------------------------------------------------------------------

// TestFilter

// string testFilePath = 1;
inline void TestFilter::clear_testfilepath() {
  _impl_.testfilepath_.ClearToEmpty();
}
inline const std::string& TestFilter::testfilepath() const {
  // @@protoc_insertion_point(field_get:testsgen.TestFilter.testFilePath)
  return _internal_testfilepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestFilter::set_testfilepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.testfilepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.TestFilter.testFilePath)
}
inline std::string* TestFilter::mutable_testfilepath() {
  std::string* _s = _internal_mutable_testfilepath();
  // @@protoc_insertion_point(field_mutable:testsgen.TestFilter.testFilePath)
  return _s;
}
inline const std::string& TestFilter::_internal_testfilepath() const {
  return _impl_.testfilepath_.Get();
}
inline void TestFilter::_internal_set_testfilepath(const std::string& value) {
  
  _impl_.testfilepath_.Set(value, GetArenaForAllocation());
}
inline std::string* TestFilter::_internal_mutable_testfilepath() {
  
  return _impl_.testfilepath_.Mutable(GetArenaForAllocation());
}
inline std::string* TestFilter::release_testfilepath() {
  // @@protoc_insertion_point(field_release:testsgen.TestFilter.testFilePath)
  return _impl_.testfilepath_.Release();
}
inline void TestFilter::set_allocated_testfilepath(std::string* testfilepath) {
  if (testfilepath != nullptr) {
    
  } else {
    
  }
  _impl_.testfilepath_.SetAllocated(testfilepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.testfilepath_.IsDefault()) {
    _impl_.testfilepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.TestFilter.testFilePath)
}

// string testName = 2;
inline void TestFilter::clear_testname() {
  _impl_.testname_.ClearToEmpty();
}
inline const std::string& TestFilter::testname() const {
  // @@protoc_insertion_point(field_get:testsgen.TestFilter.testName)
  return _internal_testname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestFilter::set_testname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.testname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.TestFilter.testName)
}
inline std::string* TestFilter::mutable_testname() {
  std::string* _s = _internal_mutable_testname();
  // @@protoc_insertion_point(field_mutable:testsgen.TestFilter.testName)
  return _s;
}
inline const std::string& TestFilter::_internal_testname() const {
  return _impl_.testname_.Get();
}
inline void TestFilter::_internal_set_testname(const std::string& value) {
  
  _impl_.testname_.Set(value, GetArenaForAllocation());
}
inline std::string* TestFilter::_internal_mutable_testname() {
  
  return _impl_.testname_.Mutable(GetArenaForAllocation());
}
inline std::string* TestFilter::release_testname() {
  // @@protoc_insertion_point(field_release:testsgen.TestFilter.testName)
  return _impl_.testname_.Release();
}
inline void TestFilter::set_allocated_testname(std::string* testname) {
  if (testname != nullptr) {
    
  } else {
    
  }
  _impl_.testname_.SetAllocated(testname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.testname_.IsDefault()) {
    _impl_.testname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.TestFilter.testName)
}

// string testSuite = 3;
inline void TestFilter::clear_testsuite() {
  _impl_.testsuite_.ClearToEmpty();
}
inline const std::string& TestFilter::testsuite() const {
  // @@protoc_insertion_point(field_get:testsgen.TestFilter.testSuite)
  return _internal_testsuite();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestFilter::set_testsuite(ArgT0&& arg0, ArgT... args) {
 
 _impl_.testsuite_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.TestFilter.testSuite)
}
inline std::string* TestFilter::mutable_testsuite() {
  std::string* _s = _internal_mutable_testsuite();
  // @@protoc_insertion_point(field_mutable:testsgen.TestFilter.testSuite)
  return _s;
}
inline const std::string& TestFilter::_internal_testsuite() const {
  return _impl_.testsuite_.Get();
}
inline void TestFilter::_internal_set_testsuite(const std::string& value) {
  
  _impl_.testsuite_.Set(value, GetArenaForAllocation());
}
inline std::string* TestFilter::_internal_mutable_testsuite() {
  
  return _impl_.testsuite_.Mutable(GetArenaForAllocation());
}
inline std::string* TestFilter::release_testsuite() {
  // @@protoc_insertion_point(field_release:testsgen.TestFilter.testSuite)
  return _impl_.testsuite_.Release();
}
inline void TestFilter::set_allocated_testsuite(std::string* testsuite) {
  if (testsuite != nullptr) {
    
  } else {
    
  }
  _impl_.testsuite_.SetAllocated(testsuite, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.testsuite_.IsDefault()) {
    _impl_.testsuite_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.TestFilter.testSuite)
}

// -------------------------------------------------------------------

// CoverageAndResultsRequest

// .testsgen.ProjectContext projectContext = 1;
inline bool CoverageAndResultsRequest::_internal_has_projectcontext() const {
  return this != internal_default_instance() && _impl_.projectcontext_ != nullptr;
}
inline bool CoverageAndResultsRequest::has_projectcontext() const {
  return _internal_has_projectcontext();
}
inline void CoverageAndResultsRequest::clear_projectcontext() {
  if (GetArenaForAllocation() == nullptr && _impl_.projectcontext_ != nullptr) {
    delete _impl_.projectcontext_;
  }
  _impl_.projectcontext_ = nullptr;
}
inline const ::testsgen::ProjectContext& CoverageAndResultsRequest::_internal_projectcontext() const {
  const ::testsgen::ProjectContext* p = _impl_.projectcontext_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::ProjectContext&>(
      ::testsgen::_ProjectContext_default_instance_);
}
inline const ::testsgen::ProjectContext& CoverageAndResultsRequest::projectcontext() const {
  // @@protoc_insertion_point(field_get:testsgen.CoverageAndResultsRequest.projectContext)
  return _internal_projectcontext();
}
inline void CoverageAndResultsRequest::unsafe_arena_set_allocated_projectcontext(
    ::testsgen::ProjectContext* projectcontext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectcontext_);
  }
  _impl_.projectcontext_ = projectcontext;
  if (projectcontext) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.CoverageAndResultsRequest.projectContext)
}
inline ::testsgen::ProjectContext* CoverageAndResultsRequest::release_projectcontext() {
  
  ::testsgen::ProjectContext* temp = _impl_.projectcontext_;
  _impl_.projectcontext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::ProjectContext* CoverageAndResultsRequest::unsafe_arena_release_projectcontext() {
  // @@protoc_insertion_point(field_release:testsgen.CoverageAndResultsRequest.projectContext)
  
  ::testsgen::ProjectContext* temp = _impl_.projectcontext_;
  _impl_.projectcontext_ = nullptr;
  return temp;
}
inline ::testsgen::ProjectContext* CoverageAndResultsRequest::_internal_mutable_projectcontext() {
  
  if (_impl_.projectcontext_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::ProjectContext>(GetArenaForAllocation());
    _impl_.projectcontext_ = p;
  }
  return _impl_.projectcontext_;
}
inline ::testsgen::ProjectContext* CoverageAndResultsRequest::mutable_projectcontext() {
  ::testsgen::ProjectContext* _msg = _internal_mutable_projectcontext();
  // @@protoc_insertion_point(field_mutable:testsgen.CoverageAndResultsRequest.projectContext)
  return _msg;
}
inline void CoverageAndResultsRequest::set_allocated_projectcontext(::testsgen::ProjectContext* projectcontext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.projectcontext_;
  }
  if (projectcontext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(projectcontext);
    if (message_arena != submessage_arena) {
      projectcontext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projectcontext, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.projectcontext_ = projectcontext;
  // @@protoc_insertion_point(field_set_allocated:testsgen.CoverageAndResultsRequest.projectContext)
}

// .testsgen.SettingsContext settingsContext = 2;
inline bool CoverageAndResultsRequest::_internal_has_settingscontext() const {
  return this != internal_default_instance() && _impl_.settingscontext_ != nullptr;
}
inline bool CoverageAndResultsRequest::has_settingscontext() const {
  return _internal_has_settingscontext();
}
inline void CoverageAndResultsRequest::clear_settingscontext() {
  if (GetArenaForAllocation() == nullptr && _impl_.settingscontext_ != nullptr) {
    delete _impl_.settingscontext_;
  }
  _impl_.settingscontext_ = nullptr;
}
inline const ::testsgen::SettingsContext& CoverageAndResultsRequest::_internal_settingscontext() const {
  const ::testsgen::SettingsContext* p = _impl_.settingscontext_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::SettingsContext&>(
      ::testsgen::_SettingsContext_default_instance_);
}
inline const ::testsgen::SettingsContext& CoverageAndResultsRequest::settingscontext() const {
  // @@protoc_insertion_point(field_get:testsgen.CoverageAndResultsRequest.settingsContext)
  return _internal_settingscontext();
}
inline void CoverageAndResultsRequest::unsafe_arena_set_allocated_settingscontext(
    ::testsgen::SettingsContext* settingscontext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settingscontext_);
  }
  _impl_.settingscontext_ = settingscontext;
  if (settingscontext) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.CoverageAndResultsRequest.settingsContext)
}
inline ::testsgen::SettingsContext* CoverageAndResultsRequest::release_settingscontext() {
  
  ::testsgen::SettingsContext* temp = _impl_.settingscontext_;
  _impl_.settingscontext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::SettingsContext* CoverageAndResultsRequest::unsafe_arena_release_settingscontext() {
  // @@protoc_insertion_point(field_release:testsgen.CoverageAndResultsRequest.settingsContext)
  
  ::testsgen::SettingsContext* temp = _impl_.settingscontext_;
  _impl_.settingscontext_ = nullptr;
  return temp;
}
inline ::testsgen::SettingsContext* CoverageAndResultsRequest::_internal_mutable_settingscontext() {
  
  if (_impl_.settingscontext_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::SettingsContext>(GetArenaForAllocation());
    _impl_.settingscontext_ = p;
  }
  return _impl_.settingscontext_;
}
inline ::testsgen::SettingsContext* CoverageAndResultsRequest::mutable_settingscontext() {
  ::testsgen::SettingsContext* _msg = _internal_mutable_settingscontext();
  // @@protoc_insertion_point(field_mutable:testsgen.CoverageAndResultsRequest.settingsContext)
  return _msg;
}
inline void CoverageAndResultsRequest::set_allocated_settingscontext(::testsgen::SettingsContext* settingscontext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.settingscontext_;
  }
  if (settingscontext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settingscontext);
    if (message_arena != submessage_arena) {
      settingscontext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settingscontext, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.settingscontext_ = settingscontext;
  // @@protoc_insertion_point(field_set_allocated:testsgen.CoverageAndResultsRequest.settingsContext)
}

// .testsgen.TestFilter testFilter = 3;
inline bool CoverageAndResultsRequest::_internal_has_testfilter() const {
  return this != internal_default_instance() && _impl_.testfilter_ != nullptr;
}
inline bool CoverageAndResultsRequest::has_testfilter() const {
  return _internal_has_testfilter();
}
inline void CoverageAndResultsRequest::clear_testfilter() {
  if (GetArenaForAllocation() == nullptr && _impl_.testfilter_ != nullptr) {
    delete _impl_.testfilter_;
  }
  _impl_.testfilter_ = nullptr;
}
inline const ::testsgen::TestFilter& CoverageAndResultsRequest::_internal_testfilter() const {
  const ::testsgen::TestFilter* p = _impl_.testfilter_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::TestFilter&>(
      ::testsgen::_TestFilter_default_instance_);
}
inline const ::testsgen::TestFilter& CoverageAndResultsRequest::testfilter() const {
  // @@protoc_insertion_point(field_get:testsgen.CoverageAndResultsRequest.testFilter)
  return _internal_testfilter();
}
inline void CoverageAndResultsRequest::unsafe_arena_set_allocated_testfilter(
    ::testsgen::TestFilter* testfilter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.testfilter_);
  }
  _impl_.testfilter_ = testfilter;
  if (testfilter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.CoverageAndResultsRequest.testFilter)
}
inline ::testsgen::TestFilter* CoverageAndResultsRequest::release_testfilter() {
  
  ::testsgen::TestFilter* temp = _impl_.testfilter_;
  _impl_.testfilter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::TestFilter* CoverageAndResultsRequest::unsafe_arena_release_testfilter() {
  // @@protoc_insertion_point(field_release:testsgen.CoverageAndResultsRequest.testFilter)
  
  ::testsgen::TestFilter* temp = _impl_.testfilter_;
  _impl_.testfilter_ = nullptr;
  return temp;
}
inline ::testsgen::TestFilter* CoverageAndResultsRequest::_internal_mutable_testfilter() {
  
  if (_impl_.testfilter_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::TestFilter>(GetArenaForAllocation());
    _impl_.testfilter_ = p;
  }
  return _impl_.testfilter_;
}
inline ::testsgen::TestFilter* CoverageAndResultsRequest::mutable_testfilter() {
  ::testsgen::TestFilter* _msg = _internal_mutable_testfilter();
  // @@protoc_insertion_point(field_mutable:testsgen.CoverageAndResultsRequest.testFilter)
  return _msg;
}
inline void CoverageAndResultsRequest::set_allocated_testfilter(::testsgen::TestFilter* testfilter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.testfilter_;
  }
  if (testfilter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(testfilter);
    if (message_arena != submessage_arena) {
      testfilter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, testfilter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.testfilter_ = testfilter;
  // @@protoc_insertion_point(field_set_allocated:testsgen.CoverageAndResultsRequest.testFilter)
}

// bool coverage = 4;
inline void CoverageAndResultsRequest::clear_coverage() {
  _impl_.coverage_ = false;
}
inline bool CoverageAndResultsRequest::_internal_coverage() const {
  return _impl_.coverage_;
}
inline bool CoverageAndResultsRequest::coverage() const {
  // @@protoc_insertion_point(field_get:testsgen.CoverageAndResultsRequest.coverage)
  return _internal_coverage();
}
inline void CoverageAndResultsRequest::_internal_set_coverage(bool value) {
  
  _impl_.coverage_ = value;
}
inline void CoverageAndResultsRequest::set_coverage(bool value) {
  _internal_set_coverage(value);
  // @@protoc_insertion_point(field_set:testsgen.CoverageAndResultsRequest.coverage)
}

// -------------------------------------------------------------------

// TestResultObject

// string testFilePath = 1;
inline void TestResultObject::clear_testfilepath() {
  _impl_.testfilepath_.ClearToEmpty();
}
inline const std::string& TestResultObject::testfilepath() const {
  // @@protoc_insertion_point(field_get:testsgen.TestResultObject.testFilePath)
  return _internal_testfilepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestResultObject::set_testfilepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.testfilepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.TestResultObject.testFilePath)
}
inline std::string* TestResultObject::mutable_testfilepath() {
  std::string* _s = _internal_mutable_testfilepath();
  // @@protoc_insertion_point(field_mutable:testsgen.TestResultObject.testFilePath)
  return _s;
}
inline const std::string& TestResultObject::_internal_testfilepath() const {
  return _impl_.testfilepath_.Get();
}
inline void TestResultObject::_internal_set_testfilepath(const std::string& value) {
  
  _impl_.testfilepath_.Set(value, GetArenaForAllocation());
}
inline std::string* TestResultObject::_internal_mutable_testfilepath() {
  
  return _impl_.testfilepath_.Mutable(GetArenaForAllocation());
}
inline std::string* TestResultObject::release_testfilepath() {
  // @@protoc_insertion_point(field_release:testsgen.TestResultObject.testFilePath)
  return _impl_.testfilepath_.Release();
}
inline void TestResultObject::set_allocated_testfilepath(std::string* testfilepath) {
  if (testfilepath != nullptr) {
    
  } else {
    
  }
  _impl_.testfilepath_.SetAllocated(testfilepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.testfilepath_.IsDefault()) {
    _impl_.testfilepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.TestResultObject.testFilePath)
}

// string testname = 2;
inline void TestResultObject::clear_testname() {
  _impl_.testname_.ClearToEmpty();
}
inline const std::string& TestResultObject::testname() const {
  // @@protoc_insertion_point(field_get:testsgen.TestResultObject.testname)
  return _internal_testname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestResultObject::set_testname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.testname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.TestResultObject.testname)
}
inline std::string* TestResultObject::mutable_testname() {
  std::string* _s = _internal_mutable_testname();
  // @@protoc_insertion_point(field_mutable:testsgen.TestResultObject.testname)
  return _s;
}
inline const std::string& TestResultObject::_internal_testname() const {
  return _impl_.testname_.Get();
}
inline void TestResultObject::_internal_set_testname(const std::string& value) {
  
  _impl_.testname_.Set(value, GetArenaForAllocation());
}
inline std::string* TestResultObject::_internal_mutable_testname() {
  
  return _impl_.testname_.Mutable(GetArenaForAllocation());
}
inline std::string* TestResultObject::release_testname() {
  // @@protoc_insertion_point(field_release:testsgen.TestResultObject.testname)
  return _impl_.testname_.Release();
}
inline void TestResultObject::set_allocated_testname(std::string* testname) {
  if (testname != nullptr) {
    
  } else {
    
  }
  _impl_.testname_.SetAllocated(testname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.testname_.IsDefault()) {
    _impl_.testname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.TestResultObject.testname)
}

// .testsgen.TestStatus status = 3;
inline void TestResultObject::clear_status() {
  _impl_.status_ = 0;
}
inline ::testsgen::TestStatus TestResultObject::_internal_status() const {
  return static_cast< ::testsgen::TestStatus >(_impl_.status_);
}
inline ::testsgen::TestStatus TestResultObject::status() const {
  // @@protoc_insertion_point(field_get:testsgen.TestResultObject.status)
  return _internal_status();
}
inline void TestResultObject::_internal_set_status(::testsgen::TestStatus value) {
  
  _impl_.status_ = value;
}
inline void TestResultObject::set_status(::testsgen::TestStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:testsgen.TestResultObject.status)
}

// string output = 4;
inline void TestResultObject::clear_output() {
  _impl_.output_.ClearToEmpty();
}
inline const std::string& TestResultObject::output() const {
  // @@protoc_insertion_point(field_get:testsgen.TestResultObject.output)
  return _internal_output();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestResultObject::set_output(ArgT0&& arg0, ArgT... args) {
 
 _impl_.output_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.TestResultObject.output)
}
inline std::string* TestResultObject::mutable_output() {
  std::string* _s = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:testsgen.TestResultObject.output)
  return _s;
}
inline const std::string& TestResultObject::_internal_output() const {
  return _impl_.output_.Get();
}
inline void TestResultObject::_internal_set_output(const std::string& value) {
  
  _impl_.output_.Set(value, GetArenaForAllocation());
}
inline std::string* TestResultObject::_internal_mutable_output() {
  
  return _impl_.output_.Mutable(GetArenaForAllocation());
}
inline std::string* TestResultObject::release_output() {
  // @@protoc_insertion_point(field_release:testsgen.TestResultObject.output)
  return _impl_.output_.Release();
}
inline void TestResultObject::set_allocated_output(std::string* output) {
  if (output != nullptr) {
    
  } else {
    
  }
  _impl_.output_.SetAllocated(output, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.output_.IsDefault()) {
    _impl_.output_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.TestResultObject.output)
}

// .google.protobuf.Duration executionTime = 5;
inline bool TestResultObject::_internal_has_executiontime() const {
  return this != internal_default_instance() && _impl_.executiontime_ != nullptr;
}
inline bool TestResultObject::has_executiontime() const {
  return _internal_has_executiontime();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& TestResultObject::_internal_executiontime() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.executiontime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& TestResultObject::executiontime() const {
  // @@protoc_insertion_point(field_get:testsgen.TestResultObject.executionTime)
  return _internal_executiontime();
}
inline void TestResultObject::unsafe_arena_set_allocated_executiontime(
    ::PROTOBUF_NAMESPACE_ID::Duration* executiontime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.executiontime_);
  }
  _impl_.executiontime_ = executiontime;
  if (executiontime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.TestResultObject.executionTime)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TestResultObject::release_executiontime() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.executiontime_;
  _impl_.executiontime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TestResultObject::unsafe_arena_release_executiontime() {
  // @@protoc_insertion_point(field_release:testsgen.TestResultObject.executionTime)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.executiontime_;
  _impl_.executiontime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TestResultObject::_internal_mutable_executiontime() {
  
  if (_impl_.executiontime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.executiontime_ = p;
  }
  return _impl_.executiontime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TestResultObject::mutable_executiontime() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_executiontime();
  // @@protoc_insertion_point(field_mutable:testsgen.TestResultObject.executionTime)
  return _msg;
}
inline void TestResultObject::set_allocated_executiontime(::PROTOBUF_NAMESPACE_ID::Duration* executiontime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.executiontime_);
  }
  if (executiontime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(executiontime));
    if (message_arena != submessage_arena) {
      executiontime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, executiontime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.executiontime_ = executiontime;
  // @@protoc_insertion_point(field_set_allocated:testsgen.TestResultObject.executionTime)
}

// -------------------------------------------------------------------

// CoverageAndResultsResponse

// repeated .testsgen.TestResultObject testRunResults = 1;
inline int CoverageAndResultsResponse::_internal_testrunresults_size() const {
  return _impl_.testrunresults_.size();
}
inline int CoverageAndResultsResponse::testrunresults_size() const {
  return _internal_testrunresults_size();
}
inline void CoverageAndResultsResponse::clear_testrunresults() {
  _impl_.testrunresults_.Clear();
}
inline ::testsgen::TestResultObject* CoverageAndResultsResponse::mutable_testrunresults(int index) {
  // @@protoc_insertion_point(field_mutable:testsgen.CoverageAndResultsResponse.testRunResults)
  return _impl_.testrunresults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::TestResultObject >*
CoverageAndResultsResponse::mutable_testrunresults() {
  // @@protoc_insertion_point(field_mutable_list:testsgen.CoverageAndResultsResponse.testRunResults)
  return &_impl_.testrunresults_;
}
inline const ::testsgen::TestResultObject& CoverageAndResultsResponse::_internal_testrunresults(int index) const {
  return _impl_.testrunresults_.Get(index);
}
inline const ::testsgen::TestResultObject& CoverageAndResultsResponse::testrunresults(int index) const {
  // @@protoc_insertion_point(field_get:testsgen.CoverageAndResultsResponse.testRunResults)
  return _internal_testrunresults(index);
}
inline ::testsgen::TestResultObject* CoverageAndResultsResponse::_internal_add_testrunresults() {
  return _impl_.testrunresults_.Add();
}
inline ::testsgen::TestResultObject* CoverageAndResultsResponse::add_testrunresults() {
  ::testsgen::TestResultObject* _add = _internal_add_testrunresults();
  // @@protoc_insertion_point(field_add:testsgen.CoverageAndResultsResponse.testRunResults)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::TestResultObject >&
CoverageAndResultsResponse::testrunresults() const {
  // @@protoc_insertion_point(field_list:testsgen.CoverageAndResultsResponse.testRunResults)
  return _impl_.testrunresults_;
}

// repeated .testsgen.FileCoverageSimplified coverages = 2;
inline int CoverageAndResultsResponse::_internal_coverages_size() const {
  return _impl_.coverages_.size();
}
inline int CoverageAndResultsResponse::coverages_size() const {
  return _internal_coverages_size();
}
inline void CoverageAndResultsResponse::clear_coverages() {
  _impl_.coverages_.Clear();
}
inline ::testsgen::FileCoverageSimplified* CoverageAndResultsResponse::mutable_coverages(int index) {
  // @@protoc_insertion_point(field_mutable:testsgen.CoverageAndResultsResponse.coverages)
  return _impl_.coverages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::FileCoverageSimplified >*
CoverageAndResultsResponse::mutable_coverages() {
  // @@protoc_insertion_point(field_mutable_list:testsgen.CoverageAndResultsResponse.coverages)
  return &_impl_.coverages_;
}
inline const ::testsgen::FileCoverageSimplified& CoverageAndResultsResponse::_internal_coverages(int index) const {
  return _impl_.coverages_.Get(index);
}
inline const ::testsgen::FileCoverageSimplified& CoverageAndResultsResponse::coverages(int index) const {
  // @@protoc_insertion_point(field_get:testsgen.CoverageAndResultsResponse.coverages)
  return _internal_coverages(index);
}
inline ::testsgen::FileCoverageSimplified* CoverageAndResultsResponse::_internal_add_coverages() {
  return _impl_.coverages_.Add();
}
inline ::testsgen::FileCoverageSimplified* CoverageAndResultsResponse::add_coverages() {
  ::testsgen::FileCoverageSimplified* _add = _internal_add_coverages();
  // @@protoc_insertion_point(field_add:testsgen.CoverageAndResultsResponse.coverages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::FileCoverageSimplified >&
CoverageAndResultsResponse::coverages() const {
  // @@protoc_insertion_point(field_list:testsgen.CoverageAndResultsResponse.coverages)
  return _impl_.coverages_;
}

// .testsgen.Progress progress = 3;
inline bool CoverageAndResultsResponse::_internal_has_progress() const {
  return this != internal_default_instance() && _impl_.progress_ != nullptr;
}
inline bool CoverageAndResultsResponse::has_progress() const {
  return _internal_has_progress();
}
inline const ::testsgen::Progress& CoverageAndResultsResponse::_internal_progress() const {
  const ::testsgen::Progress* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::Progress&>(
      ::testsgen::_Progress_default_instance_);
}
inline const ::testsgen::Progress& CoverageAndResultsResponse::progress() const {
  // @@protoc_insertion_point(field_get:testsgen.CoverageAndResultsResponse.progress)
  return _internal_progress();
}
inline void CoverageAndResultsResponse::unsafe_arena_set_allocated_progress(
    ::testsgen::Progress* progress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = progress;
  if (progress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.CoverageAndResultsResponse.progress)
}
inline ::testsgen::Progress* CoverageAndResultsResponse::release_progress() {
  
  ::testsgen::Progress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::Progress* CoverageAndResultsResponse::unsafe_arena_release_progress() {
  // @@protoc_insertion_point(field_release:testsgen.CoverageAndResultsResponse.progress)
  
  ::testsgen::Progress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::testsgen::Progress* CoverageAndResultsResponse::_internal_mutable_progress() {
  
  if (_impl_.progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::Progress>(GetArenaForAllocation());
    _impl_.progress_ = p;
  }
  return _impl_.progress_;
}
inline ::testsgen::Progress* CoverageAndResultsResponse::mutable_progress() {
  ::testsgen::Progress* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:testsgen.CoverageAndResultsResponse.progress)
  return _msg;
}
inline void CoverageAndResultsResponse::set_allocated_progress(::testsgen::Progress* progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  if (progress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(progress));
    if (message_arena != submessage_arena) {
      progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.progress_ = progress;
  // @@protoc_insertion_point(field_set_allocated:testsgen.CoverageAndResultsResponse.progress)
}

// string errorMessage = 4;
inline void CoverageAndResultsResponse::clear_errormessage() {
  _impl_.errormessage_.ClearToEmpty();
}
inline const std::string& CoverageAndResultsResponse::errormessage() const {
  // @@protoc_insertion_point(field_get:testsgen.CoverageAndResultsResponse.errorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoverageAndResultsResponse::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.errormessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.CoverageAndResultsResponse.errorMessage)
}
inline std::string* CoverageAndResultsResponse::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:testsgen.CoverageAndResultsResponse.errorMessage)
  return _s;
}
inline const std::string& CoverageAndResultsResponse::_internal_errormessage() const {
  return _impl_.errormessage_.Get();
}
inline void CoverageAndResultsResponse::_internal_set_errormessage(const std::string& value) {
  
  _impl_.errormessage_.Set(value, GetArenaForAllocation());
}
inline std::string* CoverageAndResultsResponse::_internal_mutable_errormessage() {
  
  return _impl_.errormessage_.Mutable(GetArenaForAllocation());
}
inline std::string* CoverageAndResultsResponse::release_errormessage() {
  // @@protoc_insertion_point(field_release:testsgen.CoverageAndResultsResponse.errorMessage)
  return _impl_.errormessage_.Release();
}
inline void CoverageAndResultsResponse::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  _impl_.errormessage_.SetAllocated(errormessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormessage_.IsDefault()) {
    _impl_.errormessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.CoverageAndResultsResponse.errorMessage)
}

// -------------------------------------------------------------------

// HeartbeatResponse

// bool linked = 1;
inline void HeartbeatResponse::clear_linked() {
  _impl_.linked_ = false;
}
inline bool HeartbeatResponse::_internal_linked() const {
  return _impl_.linked_;
}
inline bool HeartbeatResponse::linked() const {
  // @@protoc_insertion_point(field_get:testsgen.HeartbeatResponse.linked)
  return _internal_linked();
}
inline void HeartbeatResponse::_internal_set_linked(bool value) {
  
  _impl_.linked_ = value;
}
inline void HeartbeatResponse::set_linked(bool value) {
  _internal_set_linked(value);
  // @@protoc_insertion_point(field_set:testsgen.HeartbeatResponse.linked)
}

// -------------------------------------------------------------------

// ProjectConfigRequest

// .testsgen.ProjectContext projectContext = 1;
inline bool ProjectConfigRequest::_internal_has_projectcontext() const {
  return this != internal_default_instance() && _impl_.projectcontext_ != nullptr;
}
inline bool ProjectConfigRequest::has_projectcontext() const {
  return _internal_has_projectcontext();
}
inline void ProjectConfigRequest::clear_projectcontext() {
  if (GetArenaForAllocation() == nullptr && _impl_.projectcontext_ != nullptr) {
    delete _impl_.projectcontext_;
  }
  _impl_.projectcontext_ = nullptr;
}
inline const ::testsgen::ProjectContext& ProjectConfigRequest::_internal_projectcontext() const {
  const ::testsgen::ProjectContext* p = _impl_.projectcontext_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::ProjectContext&>(
      ::testsgen::_ProjectContext_default_instance_);
}
inline const ::testsgen::ProjectContext& ProjectConfigRequest::projectcontext() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectConfigRequest.projectContext)
  return _internal_projectcontext();
}
inline void ProjectConfigRequest::unsafe_arena_set_allocated_projectcontext(
    ::testsgen::ProjectContext* projectcontext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectcontext_);
  }
  _impl_.projectcontext_ = projectcontext;
  if (projectcontext) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.ProjectConfigRequest.projectContext)
}
inline ::testsgen::ProjectContext* ProjectConfigRequest::release_projectcontext() {
  
  ::testsgen::ProjectContext* temp = _impl_.projectcontext_;
  _impl_.projectcontext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::ProjectContext* ProjectConfigRequest::unsafe_arena_release_projectcontext() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectConfigRequest.projectContext)
  
  ::testsgen::ProjectContext* temp = _impl_.projectcontext_;
  _impl_.projectcontext_ = nullptr;
  return temp;
}
inline ::testsgen::ProjectContext* ProjectConfigRequest::_internal_mutable_projectcontext() {
  
  if (_impl_.projectcontext_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::ProjectContext>(GetArenaForAllocation());
    _impl_.projectcontext_ = p;
  }
  return _impl_.projectcontext_;
}
inline ::testsgen::ProjectContext* ProjectConfigRequest::mutable_projectcontext() {
  ::testsgen::ProjectContext* _msg = _internal_mutable_projectcontext();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectConfigRequest.projectContext)
  return _msg;
}
inline void ProjectConfigRequest::set_allocated_projectcontext(::testsgen::ProjectContext* projectcontext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.projectcontext_;
  }
  if (projectcontext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(projectcontext);
    if (message_arena != submessage_arena) {
      projectcontext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projectcontext, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.projectcontext_ = projectcontext;
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectConfigRequest.projectContext)
}

// .testsgen.ConfigMode configMode = 2;
inline void ProjectConfigRequest::clear_configmode() {
  _impl_.configmode_ = 0;
}
inline ::testsgen::ConfigMode ProjectConfigRequest::_internal_configmode() const {
  return static_cast< ::testsgen::ConfigMode >(_impl_.configmode_);
}
inline ::testsgen::ConfigMode ProjectConfigRequest::configmode() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectConfigRequest.configMode)
  return _internal_configmode();
}
inline void ProjectConfigRequest::_internal_set_configmode(::testsgen::ConfigMode value) {
  
  _impl_.configmode_ = value;
}
inline void ProjectConfigRequest::set_configmode(::testsgen::ConfigMode value) {
  _internal_set_configmode(value);
  // @@protoc_insertion_point(field_set:testsgen.ProjectConfigRequest.configMode)
}

// repeated string cmakeOptions = 3;
inline int ProjectConfigRequest::_internal_cmakeoptions_size() const {
  return _impl_.cmakeoptions_.size();
}
inline int ProjectConfigRequest::cmakeoptions_size() const {
  return _internal_cmakeoptions_size();
}
inline void ProjectConfigRequest::clear_cmakeoptions() {
  _impl_.cmakeoptions_.Clear();
}
inline std::string* ProjectConfigRequest::add_cmakeoptions() {
  std::string* _s = _internal_add_cmakeoptions();
  // @@protoc_insertion_point(field_add_mutable:testsgen.ProjectConfigRequest.cmakeOptions)
  return _s;
}
inline const std::string& ProjectConfigRequest::_internal_cmakeoptions(int index) const {
  return _impl_.cmakeoptions_.Get(index);
}
inline const std::string& ProjectConfigRequest::cmakeoptions(int index) const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectConfigRequest.cmakeOptions)
  return _internal_cmakeoptions(index);
}
inline std::string* ProjectConfigRequest::mutable_cmakeoptions(int index) {
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectConfigRequest.cmakeOptions)
  return _impl_.cmakeoptions_.Mutable(index);
}
inline void ProjectConfigRequest::set_cmakeoptions(int index, const std::string& value) {
  _impl_.cmakeoptions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:testsgen.ProjectConfigRequest.cmakeOptions)
}
inline void ProjectConfigRequest::set_cmakeoptions(int index, std::string&& value) {
  _impl_.cmakeoptions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:testsgen.ProjectConfigRequest.cmakeOptions)
}
inline void ProjectConfigRequest::set_cmakeoptions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cmakeoptions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:testsgen.ProjectConfigRequest.cmakeOptions)
}
inline void ProjectConfigRequest::set_cmakeoptions(int index, const char* value, size_t size) {
  _impl_.cmakeoptions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:testsgen.ProjectConfigRequest.cmakeOptions)
}
inline std::string* ProjectConfigRequest::_internal_add_cmakeoptions() {
  return _impl_.cmakeoptions_.Add();
}
inline void ProjectConfigRequest::add_cmakeoptions(const std::string& value) {
  _impl_.cmakeoptions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:testsgen.ProjectConfigRequest.cmakeOptions)
}
inline void ProjectConfigRequest::add_cmakeoptions(std::string&& value) {
  _impl_.cmakeoptions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:testsgen.ProjectConfigRequest.cmakeOptions)
}
inline void ProjectConfigRequest::add_cmakeoptions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cmakeoptions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:testsgen.ProjectConfigRequest.cmakeOptions)
}
inline void ProjectConfigRequest::add_cmakeoptions(const char* value, size_t size) {
  _impl_.cmakeoptions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:testsgen.ProjectConfigRequest.cmakeOptions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProjectConfigRequest::cmakeoptions() const {
  // @@protoc_insertion_point(field_list:testsgen.ProjectConfigRequest.cmakeOptions)
  return _impl_.cmakeoptions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProjectConfigRequest::mutable_cmakeoptions() {
  // @@protoc_insertion_point(field_mutable_list:testsgen.ProjectConfigRequest.cmakeOptions)
  return &_impl_.cmakeoptions_;
}

// -------------------------------------------------------------------

// ProjectConfigResponse

// .testsgen.ProjectConfigStatus type = 1;
inline void ProjectConfigResponse::clear_type() {
  _impl_.type_ = 0;
}
inline ::testsgen::ProjectConfigStatus ProjectConfigResponse::_internal_type() const {
  return static_cast< ::testsgen::ProjectConfigStatus >(_impl_.type_);
}
inline ::testsgen::ProjectConfigStatus ProjectConfigResponse::type() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectConfigResponse.type)
  return _internal_type();
}
inline void ProjectConfigResponse::_internal_set_type(::testsgen::ProjectConfigStatus value) {
  
  _impl_.type_ = value;
}
inline void ProjectConfigResponse::set_type(::testsgen::ProjectConfigStatus value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:testsgen.ProjectConfigResponse.type)
}

// string message = 2;
inline void ProjectConfigResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ProjectConfigResponse::message() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectConfigResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectConfigResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.ProjectConfigResponse.message)
}
inline std::string* ProjectConfigResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectConfigResponse.message)
  return _s;
}
inline const std::string& ProjectConfigResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ProjectConfigResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ProjectConfigResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ProjectConfigResponse::release_message() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectConfigResponse.message)
  return _impl_.message_.Release();
}
inline void ProjectConfigResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectConfigResponse.message)
}

// .testsgen.Progress progress = 3;
inline bool ProjectConfigResponse::_internal_has_progress() const {
  return this != internal_default_instance() && _impl_.progress_ != nullptr;
}
inline bool ProjectConfigResponse::has_progress() const {
  return _internal_has_progress();
}
inline const ::testsgen::Progress& ProjectConfigResponse::_internal_progress() const {
  const ::testsgen::Progress* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::Progress&>(
      ::testsgen::_Progress_default_instance_);
}
inline const ::testsgen::Progress& ProjectConfigResponse::progress() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectConfigResponse.progress)
  return _internal_progress();
}
inline void ProjectConfigResponse::unsafe_arena_set_allocated_progress(
    ::testsgen::Progress* progress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = progress;
  if (progress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.ProjectConfigResponse.progress)
}
inline ::testsgen::Progress* ProjectConfigResponse::release_progress() {
  
  ::testsgen::Progress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::Progress* ProjectConfigResponse::unsafe_arena_release_progress() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectConfigResponse.progress)
  
  ::testsgen::Progress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::testsgen::Progress* ProjectConfigResponse::_internal_mutable_progress() {
  
  if (_impl_.progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::Progress>(GetArenaForAllocation());
    _impl_.progress_ = p;
  }
  return _impl_.progress_;
}
inline ::testsgen::Progress* ProjectConfigResponse::mutable_progress() {
  ::testsgen::Progress* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectConfigResponse.progress)
  return _msg;
}
inline void ProjectConfigResponse::set_allocated_progress(::testsgen::Progress* progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  if (progress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(progress));
    if (message_arena != submessage_arena) {
      progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.progress_ = progress;
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectConfigResponse.progress)
}

// -------------------------------------------------------------------

// ProjectTarget

// string name = 1;
inline void ProjectTarget::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ProjectTarget::name() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectTarget.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectTarget::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.ProjectTarget.name)
}
inline std::string* ProjectTarget::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectTarget.name)
  return _s;
}
inline const std::string& ProjectTarget::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ProjectTarget::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ProjectTarget::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ProjectTarget::release_name() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectTarget.name)
  return _impl_.name_.Release();
}
inline void ProjectTarget::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectTarget.name)
}

// string path = 2;
inline void ProjectTarget::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& ProjectTarget::path() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectTarget.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectTarget::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.ProjectTarget.path)
}
inline std::string* ProjectTarget::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectTarget.path)
  return _s;
}
inline const std::string& ProjectTarget::_internal_path() const {
  return _impl_.path_.Get();
}
inline void ProjectTarget::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* ProjectTarget::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* ProjectTarget::release_path() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectTarget.path)
  return _impl_.path_.Release();
}
inline void ProjectTarget::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectTarget.path)
}

// string description = 3;
inline void ProjectTarget::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ProjectTarget::description() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectTarget.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectTarget::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.ProjectTarget.description)
}
inline std::string* ProjectTarget::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectTarget.description)
  return _s;
}
inline const std::string& ProjectTarget::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ProjectTarget::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ProjectTarget::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ProjectTarget::release_description() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectTarget.description)
  return _impl_.description_.Release();
}
inline void ProjectTarget::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectTarget.description)
}

// -------------------------------------------------------------------

// ProjectTargetsRequest

// .testsgen.ProjectContext projectContext = 1;
inline bool ProjectTargetsRequest::_internal_has_projectcontext() const {
  return this != internal_default_instance() && _impl_.projectcontext_ != nullptr;
}
inline bool ProjectTargetsRequest::has_projectcontext() const {
  return _internal_has_projectcontext();
}
inline void ProjectTargetsRequest::clear_projectcontext() {
  if (GetArenaForAllocation() == nullptr && _impl_.projectcontext_ != nullptr) {
    delete _impl_.projectcontext_;
  }
  _impl_.projectcontext_ = nullptr;
}
inline const ::testsgen::ProjectContext& ProjectTargetsRequest::_internal_projectcontext() const {
  const ::testsgen::ProjectContext* p = _impl_.projectcontext_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::ProjectContext&>(
      ::testsgen::_ProjectContext_default_instance_);
}
inline const ::testsgen::ProjectContext& ProjectTargetsRequest::projectcontext() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectTargetsRequest.projectContext)
  return _internal_projectcontext();
}
inline void ProjectTargetsRequest::unsafe_arena_set_allocated_projectcontext(
    ::testsgen::ProjectContext* projectcontext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectcontext_);
  }
  _impl_.projectcontext_ = projectcontext;
  if (projectcontext) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.ProjectTargetsRequest.projectContext)
}
inline ::testsgen::ProjectContext* ProjectTargetsRequest::release_projectcontext() {
  
  ::testsgen::ProjectContext* temp = _impl_.projectcontext_;
  _impl_.projectcontext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::ProjectContext* ProjectTargetsRequest::unsafe_arena_release_projectcontext() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectTargetsRequest.projectContext)
  
  ::testsgen::ProjectContext* temp = _impl_.projectcontext_;
  _impl_.projectcontext_ = nullptr;
  return temp;
}
inline ::testsgen::ProjectContext* ProjectTargetsRequest::_internal_mutable_projectcontext() {
  
  if (_impl_.projectcontext_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::ProjectContext>(GetArenaForAllocation());
    _impl_.projectcontext_ = p;
  }
  return _impl_.projectcontext_;
}
inline ::testsgen::ProjectContext* ProjectTargetsRequest::mutable_projectcontext() {
  ::testsgen::ProjectContext* _msg = _internal_mutable_projectcontext();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectTargetsRequest.projectContext)
  return _msg;
}
inline void ProjectTargetsRequest::set_allocated_projectcontext(::testsgen::ProjectContext* projectcontext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.projectcontext_;
  }
  if (projectcontext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(projectcontext);
    if (message_arena != submessage_arena) {
      projectcontext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projectcontext, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.projectcontext_ = projectcontext;
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectTargetsRequest.projectContext)
}

// -------------------------------------------------------------------

// ProjectTargetsResponse

// repeated .testsgen.ProjectTarget targets = 1;
inline int ProjectTargetsResponse::_internal_targets_size() const {
  return _impl_.targets_.size();
}
inline int ProjectTargetsResponse::targets_size() const {
  return _internal_targets_size();
}
inline void ProjectTargetsResponse::clear_targets() {
  _impl_.targets_.Clear();
}
inline ::testsgen::ProjectTarget* ProjectTargetsResponse::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectTargetsResponse.targets)
  return _impl_.targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::ProjectTarget >*
ProjectTargetsResponse::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:testsgen.ProjectTargetsResponse.targets)
  return &_impl_.targets_;
}
inline const ::testsgen::ProjectTarget& ProjectTargetsResponse::_internal_targets(int index) const {
  return _impl_.targets_.Get(index);
}
inline const ::testsgen::ProjectTarget& ProjectTargetsResponse::targets(int index) const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectTargetsResponse.targets)
  return _internal_targets(index);
}
inline ::testsgen::ProjectTarget* ProjectTargetsResponse::_internal_add_targets() {
  return _impl_.targets_.Add();
}
inline ::testsgen::ProjectTarget* ProjectTargetsResponse::add_targets() {
  ::testsgen::ProjectTarget* _add = _internal_add_targets();
  // @@protoc_insertion_point(field_add:testsgen.ProjectTargetsResponse.targets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::ProjectTarget >&
ProjectTargetsResponse::targets() const {
  // @@protoc_insertion_point(field_list:testsgen.ProjectTargetsResponse.targets)
  return _impl_.targets_;
}

// .testsgen.ProjectTarget priorityTarget = 2;
inline bool ProjectTargetsResponse::_internal_has_prioritytarget() const {
  return this != internal_default_instance() && _impl_.prioritytarget_ != nullptr;
}
inline bool ProjectTargetsResponse::has_prioritytarget() const {
  return _internal_has_prioritytarget();
}
inline void ProjectTargetsResponse::clear_prioritytarget() {
  if (GetArenaForAllocation() == nullptr && _impl_.prioritytarget_ != nullptr) {
    delete _impl_.prioritytarget_;
  }
  _impl_.prioritytarget_ = nullptr;
}
inline const ::testsgen::ProjectTarget& ProjectTargetsResponse::_internal_prioritytarget() const {
  const ::testsgen::ProjectTarget* p = _impl_.prioritytarget_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::ProjectTarget&>(
      ::testsgen::_ProjectTarget_default_instance_);
}
inline const ::testsgen::ProjectTarget& ProjectTargetsResponse::prioritytarget() const {
  // @@protoc_insertion_point(field_get:testsgen.ProjectTargetsResponse.priorityTarget)
  return _internal_prioritytarget();
}
inline void ProjectTargetsResponse::unsafe_arena_set_allocated_prioritytarget(
    ::testsgen::ProjectTarget* prioritytarget) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prioritytarget_);
  }
  _impl_.prioritytarget_ = prioritytarget;
  if (prioritytarget) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.ProjectTargetsResponse.priorityTarget)
}
inline ::testsgen::ProjectTarget* ProjectTargetsResponse::release_prioritytarget() {
  
  ::testsgen::ProjectTarget* temp = _impl_.prioritytarget_;
  _impl_.prioritytarget_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::ProjectTarget* ProjectTargetsResponse::unsafe_arena_release_prioritytarget() {
  // @@protoc_insertion_point(field_release:testsgen.ProjectTargetsResponse.priorityTarget)
  
  ::testsgen::ProjectTarget* temp = _impl_.prioritytarget_;
  _impl_.prioritytarget_ = nullptr;
  return temp;
}
inline ::testsgen::ProjectTarget* ProjectTargetsResponse::_internal_mutable_prioritytarget() {
  
  if (_impl_.prioritytarget_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::ProjectTarget>(GetArenaForAllocation());
    _impl_.prioritytarget_ = p;
  }
  return _impl_.prioritytarget_;
}
inline ::testsgen::ProjectTarget* ProjectTargetsResponse::mutable_prioritytarget() {
  ::testsgen::ProjectTarget* _msg = _internal_mutable_prioritytarget();
  // @@protoc_insertion_point(field_mutable:testsgen.ProjectTargetsResponse.priorityTarget)
  return _msg;
}
inline void ProjectTargetsResponse::set_allocated_prioritytarget(::testsgen::ProjectTarget* prioritytarget) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.prioritytarget_;
  }
  if (prioritytarget) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prioritytarget);
    if (message_arena != submessage_arena) {
      prioritytarget = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prioritytarget, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prioritytarget_ = prioritytarget;
  // @@protoc_insertion_point(field_set_allocated:testsgen.ProjectTargetsResponse.priorityTarget)
}

// -------------------------------------------------------------------

// FileTargetsRequest

// string path = 1;
inline void FileTargetsRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& FileTargetsRequest::path() const {
  // @@protoc_insertion_point(field_get:testsgen.FileTargetsRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileTargetsRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:testsgen.FileTargetsRequest.path)
}
inline std::string* FileTargetsRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:testsgen.FileTargetsRequest.path)
  return _s;
}
inline const std::string& FileTargetsRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void FileTargetsRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* FileTargetsRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* FileTargetsRequest::release_path() {
  // @@protoc_insertion_point(field_release:testsgen.FileTargetsRequest.path)
  return _impl_.path_.Release();
}
inline void FileTargetsRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:testsgen.FileTargetsRequest.path)
}

// .testsgen.ProjectContext projectContext = 2;
inline bool FileTargetsRequest::_internal_has_projectcontext() const {
  return this != internal_default_instance() && _impl_.projectcontext_ != nullptr;
}
inline bool FileTargetsRequest::has_projectcontext() const {
  return _internal_has_projectcontext();
}
inline void FileTargetsRequest::clear_projectcontext() {
  if (GetArenaForAllocation() == nullptr && _impl_.projectcontext_ != nullptr) {
    delete _impl_.projectcontext_;
  }
  _impl_.projectcontext_ = nullptr;
}
inline const ::testsgen::ProjectContext& FileTargetsRequest::_internal_projectcontext() const {
  const ::testsgen::ProjectContext* p = _impl_.projectcontext_;
  return p != nullptr ? *p : reinterpret_cast<const ::testsgen::ProjectContext&>(
      ::testsgen::_ProjectContext_default_instance_);
}
inline const ::testsgen::ProjectContext& FileTargetsRequest::projectcontext() const {
  // @@protoc_insertion_point(field_get:testsgen.FileTargetsRequest.projectContext)
  return _internal_projectcontext();
}
inline void FileTargetsRequest::unsafe_arena_set_allocated_projectcontext(
    ::testsgen::ProjectContext* projectcontext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectcontext_);
  }
  _impl_.projectcontext_ = projectcontext;
  if (projectcontext) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:testsgen.FileTargetsRequest.projectContext)
}
inline ::testsgen::ProjectContext* FileTargetsRequest::release_projectcontext() {
  
  ::testsgen::ProjectContext* temp = _impl_.projectcontext_;
  _impl_.projectcontext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::testsgen::ProjectContext* FileTargetsRequest::unsafe_arena_release_projectcontext() {
  // @@protoc_insertion_point(field_release:testsgen.FileTargetsRequest.projectContext)
  
  ::testsgen::ProjectContext* temp = _impl_.projectcontext_;
  _impl_.projectcontext_ = nullptr;
  return temp;
}
inline ::testsgen::ProjectContext* FileTargetsRequest::_internal_mutable_projectcontext() {
  
  if (_impl_.projectcontext_ == nullptr) {
    auto* p = CreateMaybeMessage<::testsgen::ProjectContext>(GetArenaForAllocation());
    _impl_.projectcontext_ = p;
  }
  return _impl_.projectcontext_;
}
inline ::testsgen::ProjectContext* FileTargetsRequest::mutable_projectcontext() {
  ::testsgen::ProjectContext* _msg = _internal_mutable_projectcontext();
  // @@protoc_insertion_point(field_mutable:testsgen.FileTargetsRequest.projectContext)
  return _msg;
}
inline void FileTargetsRequest::set_allocated_projectcontext(::testsgen::ProjectContext* projectcontext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.projectcontext_;
  }
  if (projectcontext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(projectcontext);
    if (message_arena != submessage_arena) {
      projectcontext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projectcontext, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.projectcontext_ = projectcontext;
  // @@protoc_insertion_point(field_set_allocated:testsgen.FileTargetsRequest.projectContext)
}

// -------------------------------------------------------------------

// FileTargetsResponse

// repeated .testsgen.ProjectTarget targets = 1;
inline int FileTargetsResponse::_internal_targets_size() const {
  return _impl_.targets_.size();
}
inline int FileTargetsResponse::targets_size() const {
  return _internal_targets_size();
}
inline void FileTargetsResponse::clear_targets() {
  _impl_.targets_.Clear();
}
inline ::testsgen::ProjectTarget* FileTargetsResponse::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:testsgen.FileTargetsResponse.targets)
  return _impl_.targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::ProjectTarget >*
FileTargetsResponse::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:testsgen.FileTargetsResponse.targets)
  return &_impl_.targets_;
}
inline const ::testsgen::ProjectTarget& FileTargetsResponse::_internal_targets(int index) const {
  return _impl_.targets_.Get(index);
}
inline const ::testsgen::ProjectTarget& FileTargetsResponse::targets(int index) const {
  // @@protoc_insertion_point(field_get:testsgen.FileTargetsResponse.targets)
  return _internal_targets(index);
}
inline ::testsgen::ProjectTarget* FileTargetsResponse::_internal_add_targets() {
  return _impl_.targets_.Add();
}
inline ::testsgen::ProjectTarget* FileTargetsResponse::add_targets() {
  ::testsgen::ProjectTarget* _add = _internal_add_targets();
  // @@protoc_insertion_point(field_add:testsgen.FileTargetsResponse.targets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::testsgen::ProjectTarget >&
FileTargetsResponse::targets() const {
  // @@protoc_insertion_point(field_list:testsgen.FileTargetsResponse.targets)
  return _impl_.targets_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace testsgen

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::testsgen::TestStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::testsgen::TestStatus>() {
  return ::testsgen::TestStatus_descriptor();
}
template <> struct is_proto_enum< ::testsgen::ConfigMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::testsgen::ConfigMode>() {
  return ::testsgen::ConfigMode_descriptor();
}
template <> struct is_proto_enum< ::testsgen::ProjectConfigStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::testsgen::ProjectConfigStatus>() {
  return ::testsgen::ProjectConfigStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_testgen_2eproto
